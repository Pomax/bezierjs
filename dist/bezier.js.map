{"version":3,"file":"bezier.js","sources":["../src/utils.js","../src/PolyBezier.js","../src/svg-to-beziers.js","../src/normalise-svg.js","../src/Bezier.js"],"sourcesContent":["import { Bezier } from './Bezier';\n\n// math-inlining.\nconst abs = Math.abs;\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst acos = Math.acos;\nconst atan2 = Math.atan2;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\n// cube root function yielding real roots\nconst crt = function (v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n};\n// trig constants\nconst pi = Math.PI;\nconst tau = 2 * pi;\nconst quart = pi / 2;\n// float precision significant decimal\nconst epsilon = 0.000001;\n// extremas used in bbox calculation and similar algorithms\nconst nMax = Number.MAX_SAFE_INTEGER || 9007199254740991;\nconst nMin = Number.MIN_SAFE_INTEGER || -9007199254740991;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * @ignore\n */\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759\n  ],\n\n  arcfn (t, derivativeFn) {\n    var d = derivativeFn(t);\n    var l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== 'undefined') {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  /**\n   * Computes the point at {@code t} on the integral bezier curve defined by the control points {@code points}.\n   *\n   * @param {number} t - parameter to evaluate at\n   * @param {Array<{ x: number, y: number, z?: number }>} points - the control points\n   * @param {boolean}[_3d] - whether the bezier curve is in 3-space\n   */\n  compute (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      return points[order];\n    }\n\n    let p = points;\n    const mt = 1 - t;\n\n    // constant?\n    if (order === 0) {\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      const mt2 = mt * mt;\n      const t2 = t * t;\n      let a;\n      let b;\n      let c;\n      let d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    var dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (var i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t\n        };\n        if (typeof dCpts[i].z !== 'undefined') {\n          dCpts[i] = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n\n    return dCpts[0];\n  },\n\n  /**\n   * Computes the point at {@code t} on the rational bezier curve defined by {@code points} and their\n   * {@code ratios}.\n   *\n   * @param {number} t\n   * @param {Array<{ x: number, y: number, z?: number }>} points\n   * @param {Array<number>} ratios\n   * @param {boolean}[_3d]\n   */\n  computeWithRatios (t, points, ratios, _3d) {\n    const mt = 1 - t;\n    const r = ratios;\n    const p = points;\n    let d;\n    let f1 = r[0]; let f2 = r[1]; let f3 = r[2]; let f4 = r[3];\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d\n      };\n    }\n  },\n\n  /**\n   * Calculates the n-order derivatives of the integral bezier curve defined by {@code points}, where\n   * 1 < n â‰¤ {@code points.length - 1}.\n   *\n   * @param {Array<{ x: number, y: number, z?: number}>} points - control points of the bezier curve\n   * @param {boolean} _3d - whether the control points are defined in 3-space\n   * @returns {Array<Array<{ x: number, y: number, z?: number}>>} - control points of each derivative, in order of\n   *    ascending derivative order.\n   * @see https://pomax.github.io/bezierinfo/#derivatives\n   */\n  derive (points, _3d) {\n    const dpoints = []; // Control points of each derivative\n\n    let p = points;\n    let d = p.length; // Number of control points in curve being differentiated\n    let c = d - 1; // Number of control points in the next derivative\n\n    for (; d > 1; d--, c--) {\n      const list = new Array(c);\n\n      for (let j = 0; j < c; j++) {\n        const dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y)\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n\n        list[j] = dpt;\n      }\n\n      dpoints.push(list);\n      p = list;\n    }\n\n    return dpoints;\n  },\n\n  between (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length (derivativeFn) {\n    var z = 0.5;\n    var sum = 0;\n    var len = utils.Tvalues.length;\n    var i;\n    var t;\n    for (i = 0; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map (v, ds, de, ts, te) {\n    var d1 = de - ds;\n    var d2 = te - ts;\n    var v2 = v - ds;\n    var r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp (r, v1, v2) {\n    var ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y)\n    };\n    if (!!v1.z && !!v2.z) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString (p) {\n    var s = p.x + '/' + p.y;\n    if (typeof p.z !== 'undefined') {\n      s += '/' + p.z;\n    }\n    return s;\n  },\n\n  pointsToString (points) {\n    return '[' + points.map(utils.pointToString).join(', ') + ']';\n  },\n\n  copy (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle (o, v1, v2) {\n    var dx1 = v1.x - o.x;\n    var dy1 = v1.y - o.y;\n    var dx2 = v2.x - o.x;\n    var dy2 = v2.y - o.y;\n    var cross = dx1 * dy2 - dy1 * dx2;\n    var dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round (v, d) {\n    var s = '' + v;\n    var pos = s.indexOf('.');\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist (p1, p2) {\n    var dx = p1.x - p2.x;\n    var dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest (LUT, point) {\n    var mdist = pow(2, 63);\n    var mpos;\n    var d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === 'undefined') {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    var bottom = pow(t, n) + pow(1 - t, n);\n    var top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === 'undefined') {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    var top = pow(1 - t, n);\n    var bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8 (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n    const ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n    const d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n    if (d === 0) {\n      return false;\n    }\n\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4 (p1, p2, p3, p4) {\n    return utils.lli8(\n      p1.x, p1.y,\n      p2.x, p2.y,\n      p3.x, p3.y,\n      p4.x, p4.y);\n  },\n\n  lli (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline (p1, p2) {\n    var x1 = p1.x;\n    var y1 = p1.y;\n    var x2 = p2.x;\n    var y2 = p2.y;\n    var dx = (x2 - x1) / 3;\n    var dy = (y2 - y1) / 3;\n    return new Bezier(\n      x1,\n      y1,\n      x1 + dx,\n      y1 + dy,\n      x1 + 2 * dx,\n      y1 + 2 * dy,\n      x2,\n      y2\n    );\n  },\n\n  findbbox (sections) {\n    var mx = nMax;\n    var my = nMax;\n    var MX = nMin;\n    var MY = nMin;\n    sections.forEach(function (s) {\n      var bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my }\n    };\n  },\n\n  shapeintersections (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    var intersections = [];\n    var a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    var a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        var iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape (forward, back, curveIntersectionThreshold) {\n    var bpl = back.points.length;\n    var fpl = forward.points.length;\n    var start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    var end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    var shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end])\n    };\n    var self = utils;\n    shape.intersections = function (s2) {\n      return self.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    var min = nMax;\n    var max = nMin;\n    var t;\n    var c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (var i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align (points, line) {\n    var tx = line.p1.x;\n    var ty = line.p1.y;\n    var a = -atan2(line.p2.y - ty, line.p2.x - tx);\n    var d = function (v) {\n      return {\n        x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n        y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a)\n      };\n    };\n    return points.map(d);\n  },\n\n  roots (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n    const order = points.length - 1;\n    var p = utils.align(points, line);\n\n    const reduce = function (t) {\n      return t >= 0 && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = p[0].y;\n      const b = p[1].y;\n      const c = p[2].y;\n      const d = a - 2 * b + c;\n\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c);\n        const m2 = -a + b;\n        const v1 = -(m1 + m2) / d;\n        const v2 = -(-m1 + m2) / d;\n\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    var pa = p[0].y;\n    var pb = p[1].y;\n    var pc = p[2].y;\n    var pd = p[3].y;\n    var d = -pa + 3 * pb - 3 * pc + pd;\n    var a = 3 * pa - 6 * pb + 3 * pc;\n    var b = -3 * pa + 3 * pb;\n    var c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      var q = sqrt(b * b - 4 * a * c);\n      var a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n    a /= d;\n    b /= d;\n    c /= d;\n\n    p = (3 * b - a * a) / 3;\n    var p3 = p / 3;\n    q = (2 * a * a * a - 9 * a * b + 27 * c) / 27;\n    var q2 = q / 2;\n    var discriminant = q2 * q2 + p3 * p3 * p3;\n    var u1;\n    var v1;\n    var x1;\n    var x2;\n    var x3;\n\n    if (discriminant < 0) {\n      var mp3 = -p / 3;\n      var mp33 = mp3 * mp3 * mp3;\n      var r = sqrt(mp33);\n      var t = -q / (2 * r);\n      var cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\n      var phi = acos(cosphi);\n      var crtr = crt(r);\n      var t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n\n      return [x1, x2].filter(reduce);\n    } else {\n      var sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      var a = p[0];\n      var b = p[1];\n      var c = p[2];\n      var d = a - 2 * b + c;\n      if (d !== 0) {\n        var m1 = -sqrt(b * b - a * c);\n        var m2 = -a + b;\n        var v1 = -(m1 + m2) / d;\n        var v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0];\n      const b = p[1];\n\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n\n      return [];\n    }\n  },\n\n  curvature (t, points, _3d, kOnly) {\n    var dpoints = utils.derive(points);\n    var d1 = dpoints[0];\n    var d2 = dpoints[1];\n    var num; var dnm; var adk; var dk; var k = 0; var r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x'Â² + y'Â²)^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z')Â² + (z'x\" - z\"x')Â² + (x'y\" - x\"y')Â²)\n    //   k(t) = -------------------------------------------------------\n    //                     (x'Â² + y'Â² + z'Â²)^(3/2)\n    //\n\n    var d = utils.compute(t, d1);\n    var dd = utils.compute(t, d2);\n    var qdsum = d.x * d.x + d.y * d.y;\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n        pow(d.z * dd.x - dd.z * d.x, 2) +\n        pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      var pk = utils.curvature(t - 0.001, points, _3d, true).k;\n      var nk = utils.curvature(t + 0.001, points, _3d, true).k;\n      dk = ((nk - k) + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    var p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] });\n    var a = p[2].x * p[1].y;\n    var b = p[3].x * p[1].y;\n    var c = p[1].x * p[2].y;\n    var d = p[3].x * p[2].y;\n    var v1 = 18 * (-3 * a + 2 * b + 3 * c - d);\n    var v2 = 18 * (3 * a - b - 3 * c);\n    var v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        var t = -v3 / v2;\n        if (t >= 0 && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    var trm = v2 * v2 - 4 * v1 * v3;\n    var sq = Math.sqrt(trm);\n    d = 2 * v1;\n\n    if (utils.approximately(d, 0)) return [];\n\n    return [(sq - v2) / d, -(v2 + sq) / d].filter(function (r) {\n      return r >= 0 && r <= 1;\n    });\n  },\n\n  bboxoverlap (b1, b2) {\n    var dims = ['x', 'y'];\n    var len = dims.length;\n    var i;\n    var dim;\n    var l;\n    var t;\n    var d;\n    for (i = 0; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration (c1, c2, curveIntersectionThreshold) {\n    var c1b = c1.bbox();\n    var c2b = c2.bbox();\n    var r = 100000;\n    var threshold = curveIntersectionThreshold || 0.5;\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        ((r * (c1._t1 + c1._t2) / 2) | 0) / r +\n          '/' +\n          ((r * (c2._t1 + c2._t2) / 2) | 0) / r\n      ];\n    }\n    var cc1 = c1.split(0.5);\n    var cc2 = c2.split(0.5);\n    var pairs = [\n      { left: cc1.left, right: cc2.left },\n      { left: cc1.left, right: cc2.right },\n      { left: cc1.right, right: cc2.right },\n      { left: cc1.right, right: cc2.left }\n    ];\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n    var results = [];\n    if (pairs.length === 0) return results;\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n    return results;\n  },\n\n  getccenter (p1, p2, p3) {\n    var dx1 = p2.x - p1.x;\n    var dy1 = p2.y - p1.y;\n    var dx2 = p3.x - p2.x;\n    var dy2 = p3.y - p2.y;\n    var dx1p = dx1 * cos(quart) - dy1 * sin(quart);\n    var dy1p = dx1 * sin(quart) + dy1 * cos(quart);\n    var dx2p = dx2 * cos(quart) - dy2 * sin(quart);\n    var dy2p = dx2 * sin(quart) + dy2 * cos(quart);\n    // chord midpoints\n    var mx1 = (p1.x + p2.x) / 2;\n    var my1 = (p1.y + p2.y) / 2;\n    var mx2 = (p2.x + p3.x) / 2;\n    var my2 = (p2.y + p3.y) / 2;\n    // midpoint offsets\n    var mx1n = mx1 + dx1p;\n    var my1n = my1 + dy1p;\n    var mx2n = mx2 + dx2p;\n    var my2n = my2 + dy2p;\n    // intersection of these lines:\n    var arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n);\n    var r = utils.dist(arc, p1);\n    // arc start/end values, over mid point:\n    var s = atan2(p1.y - arc.y, p1.x - arc.x);\n    var m = atan2(p2.y - arc.y, p2.x - arc.x);\n    var e = atan2(p3.y - arc.y, p3.x - arc.x);\n    var _;\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort (a, b) {\n    return a - b;\n  }\n};\n\nexport default utils;\n","import utils from './utils';\n\n/**\n * {@code PolyBezier} is a spline composed of {@link Bezier} curves.\n */\nexport class PolyBezier {\n  /**\n   * Poly Bezier\n   * @param {Bezier[]}[curves]\n   */\n  constructor (curves) {\n    this.curves = [];\n    this._3d = false;\n\n    if (curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf () {\n    return this.toString();\n  }\n\n  toString () {\n    return (\n      '[' +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(', ') +\n      ']'\n    );\n  }\n\n  /**\n   * @param {Bezier} curve\n   */\n  addCurve (curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  /**\n   * @returns {number} the sum of the arc lengths of each subcurve\n   */\n  length () {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve (idx) {\n    return this.curves[idx];\n  }\n\n  bbox () {\n    var c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset (d) {\n    let offset = [];\n\n    this.curves.forEach(function (v) {\n      offset = offset.concat(v.offset(d));\n    });\n\n    return new PolyBezier(offset);\n  }\n}\n","import { normalisePath as normalise } from './normalise-svg';\n\nvar M = { x: false, y: false };\n\nfunction makeBezier (Bezier, term, values) {\n  if (term === 'Z') return;\n  if (term === 'M') {\n    M = { x: values[0], y: values[1] };\n    return;\n  }\n  // ES7: new Bezier(M.x, M.y, ...values)\n  var cvalues = [false, M.x, M.y].concat(values);\n  var PreboundConstructor = Bezier.bind.apply(Bezier, cvalues);\n  var curve = new PreboundConstructor();\n  var last = values.slice(-2);\n  M = { x: last[0], y: last[1] };\n  return curve;\n}\n\nexport function convertPath (Bezier, d) {\n  var terms = normalise(d).split(' ');\n  var term;\n  var matcher = new RegExp('[MLCQZ]', '');\n  var segment;\n  var values;\n  var segments = [];\n  var ARGS = { C: 6, Q: 4, L: 2, M: 2 };\n\n  while (terms.length) {\n    term = terms.splice(0, 1)[0];\n    if (matcher.test(term)) {\n      values = terms.splice(0, ARGS[term]).map(parseFloat);\n      segment = makeBezier(Bezier, term, values);\n      if (segment) segments.push(segment);\n    }\n  }\n\n  return new Bezier.PolyBezier(segments);\n}\n","/**\n * Normalise an SVG path to absolute coordinates\n * and full commands, rather than relative coordinates\n * and/or shortcut commands.\n */\nexport function normalisePath (d) {\n  // preprocess \"d\" so that we have spaces between values\n  d = d\n    .replace(/,/g, ' ') // replace commas with spaces\n    .replace(/-/g, ' - ') // add spacing around minus signs\n    .replace(/-\\s+/g, '-') // remove spacing to the right of minus signs.\n    .replace(/([a-zA-Z])/g, ' $1 ');\n\n  // set up the variables used in this function\n  const instructions = d.replace(/([a-zA-Z])\\s?/g, '|$1').split('|');\n  const instructionLength = instructions.length;\n  let i;\n  let instruction;\n  let op;\n  let lop;\n  let args = [];\n  let alen;\n  let a;\n  let sx = 0;\n  let sy = 0;\n  let x = 0;\n  let y = 0;\n  let cx = 0;\n  let cy = 0;\n  let cx2 = 0;\n  let cy2 = 0;\n  let normalized = '';\n\n  // we run through the instruction list starting at 1, not 0,\n  // because we split up \"|M x y ....\" so the first element will\n  // always be an empty string. By design.\n  for (i = 1; i < instructionLength; i++) {\n    // which instruction is this?\n    instruction = instructions[i];\n    op = instruction.substring(0, 1);\n    lop = op.toLowerCase();\n\n    // what are the arguments? note that we need to convert\n    // all strings into numbers, or + will do silly things.\n    args = instruction\n      .replace(op, '')\n      .trim()\n      .split(' ');\n    args = args\n      .filter(function (v) {\n        return v !== '';\n      })\n      .map(parseFloat);\n    alen = args.length;\n\n    // we could use a switch, but elaborate code in a \"case\" with\n    // fallthrough is just horrid to read. So let's use ifthen\n    // statements instead.\n\n    // moveto command (plus possible lineto)\n    if (lop === 'm') {\n      normalized += 'M ';\n      if (op === 'm') {\n        x += args[0];\n        y += args[1];\n      } else {\n        x = args[0];\n        y = args[1];\n      }\n      // records start position, for dealing\n      // with the shape close operator ('Z')\n      sx = x;\n      sy = y;\n      normalized += x + ' ' + y + ' ';\n      if (alen > 2) {\n        for (a = 0; a < alen; a += 2) {\n          if (op === 'm') {\n            x += args[a];\n            y += args[a + 1];\n          } else {\n            x = args[a];\n            y = args[a + 1];\n          }\n          normalized += ['L', x, y, ''].join(' ');\n        }\n      }\n    } else if (lop === 'l') {\n      // lineto commands\n      for (a = 0; a < alen; a += 2) {\n        if (op === 'l') {\n          x += args[a];\n          y += args[a + 1];\n        } else {\n          x = args[a];\n          y = args[a + 1];\n        }\n        normalized += ['L', x, y, ''].join(' ');\n      }\n    } else if (lop === 'h') {\n      for (a = 0; a < alen; a++) {\n        if (op === 'h') {\n          x += args[a];\n        } else {\n          x = args[a];\n        }\n        normalized += ['L', x, y, ''].join(' ');\n      }\n    } else if (lop === 'v') {\n      for (a = 0; a < alen; a++) {\n        if (op === 'v') {\n          y += args[a];\n        } else {\n          y = args[a];\n        }\n        normalized += ['L', x, y, ''].join(' ');\n      }\n    } else if (lop === 'q') {\n      // quadratic curveto commands\n      for (a = 0; a < alen; a += 4) {\n        if (op === 'q') {\n          cx = x + args[a];\n          cy = y + args[a + 1];\n          x += args[a + 2];\n          y += args[a + 3];\n        } else {\n          cx = args[a];\n          cy = args[a + 1];\n          x = args[a + 2];\n          y = args[a + 3];\n        }\n        normalized += ['Q', cx, cy, x, y, ''].join(' ');\n      }\n    } else if (lop === 't') {\n      for (a = 0; a < alen; a += 2) {\n        // reflect previous cx/cy over x/y\n        cx = x + (x - cx);\n        cy = y + (y - cy);\n        // then get real end point\n        if (op === 't') {\n          x += args[a];\n          y += args[a + 1];\n        } else {\n          x = args[a];\n          y = args[a + 1];\n        }\n        normalized += ['Q', cx, cy, x, y, ''].join(' ');\n      }\n    } else if (lop === 'c') {\n      // cubic curveto commands\n      for (a = 0; a < alen; a += 6) {\n        if (op === 'c') {\n          cx = x + args[a];\n          cy = y + args[a + 1];\n          cx2 = x + args[a + 2];\n          cy2 = y + args[a + 3];\n          x += args[a + 4];\n          y += args[a + 5];\n        } else {\n          cx = args[a];\n          cy = args[a + 1];\n          cx2 = args[a + 2];\n          cy2 = args[a + 3];\n          x = args[a + 4];\n          y = args[a + 5];\n        }\n        normalized += ['C', cx, cy, cx2, cy2, x, y, ''].join(' ');\n      }\n    } else if (lop === 's') {\n      for (a = 0; a < alen; a += 4) {\n        // reflect previous cx2/cy2 over x/y\n        cx = x + (x - cx2);\n        cy = y + (y - cy2);\n        // then get real control and end point\n        if (op === 's') {\n          cx2 = x + args[a];\n          cy2 = y + args[a + 1];\n          x += args[a + 2];\n          y += args[a + 3];\n        } else {\n          cx2 = args[a];\n          cy2 = args[a + 1];\n          x = args[a + 2];\n          y = args[a + 3];\n        }\n        normalized += ['C', cx, cy, cx2, cy2, x, y, ''].join(' ');\n      }\n    } else if (lop === 'z') {\n      normalized += 'Z ';\n      // not unimportant: path closing changes the current x/y coordinate\n      x = sx;\n      y = sy;\n    }\n  }\n\n  return normalized.trim();\n}\n","import utils from './utils.js';// quite needed\nimport { PolyBezier } from './PolyBezier';// only used for outlines atm.\nimport { convertPath as svgToBeziers } from './svg-to-beziers';\n\nconst abs = Math.abs;\nconst min = Math.min;\nconst max = Math.max;\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst acos = Math.acos;\nconst sqrt = Math.sqrt;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n// Components of vectors in 2-space\n// const VECTOR2_COMPONENTS = ['x', 'y'];\n\n// Components of vectors in 3-space\nconst VECTOR3_COMPONENTS = ['x', 'y', 'z'];\n\nfunction getABC (n, S, B, E, t) {\n  if (typeof t === 'undefined') {\n    t = 0.5;\n  }\n  var u = utils.projectionratio(t, n);\n  var um = 1 - u;\n  var C = {\n    x: u * S.x + um * E.x,\n    y: u * S.y + um * E.y\n  };\n  var s = utils.abcratio(t, n);\n  var A = {\n    x: B.x + (B.x - C.x) / s,\n    y: B.y + (B.y - C.y) / s\n  };\n  return { A: A, B: B, C: C };\n}\n\nexport class Bezier {\n  /**\n   * Bezier curve constructor. The constructor argument can be one of three things:\n   *\n   * 1. array/4 of {x:..., y:..., z:...}, z optional\n   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4\n   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4\n   *\n   * @param {*} coords\n   */\n  constructor (coords) {\n    let args = coords && coords.forEach ? coords : [].slice.call(arguments);\n    let coordlen = false;\n\n    if (typeof args[0] === 'object') {\n      coordlen = args.length;\n\n      const newargs = [];\n\n      args.forEach((point) => {\n        VECTOR3_COMPONENTS.forEach(function (d) {\n          if (typeof point[d] !== 'undefined') {\n            newargs.push(point[d]);\n          }\n        });\n      });\n\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            'Only new Bezier(point[]) is accepted for 4th and higher order curves'\n          );\n        }\n\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            'Only new Bezier(point[]) is accepted for 4th and higher order curves'\n          );\n        }\n      }\n    }\n\n    const _3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== 'undefined');\n    this._3d = _3d;\n\n    const points = [];\n\n    for (var idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      const point = {\n        x: args[idx],\n        y: args[idx + 1]\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n\n      points.push(point);\n    }\n\n    this.order = points.length - 1;\n    this.points = points;\n\n    var dims = ['x', 'y'];\n    if (_3d) dims.push('z');\n\n    this.dims = dims;\n    this.dimlen = dims.length;\n\n    (function (curve) {\n      var order = curve.order;\n      var points = curve.points;\n      var a = utils.align(points, { p1: points[0], p2: points[order] });\n      for (var i = 0; i < a.length; i++) {\n        if (abs(a[i].y) > 0.0001) {\n          curve._linear = false;\n          return;\n        }\n      }\n      curve._linear = true;\n    })(this);\n\n    this._t1 = 0;\n    this._t2 = 1;\n\n    this.update();\n  }\n\n  point (idx) {\n    return this.points[idx];\n  }\n\n  get (t) {\n    return this.compute(t);\n  }\n\n  compute (t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  /**\n   * @param {number[]} ratios - ratios of each control points\n   */\n  setRatios (ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error('Incorrect number of ratio values');\n    }\n\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  /**\n   * @param {number} steps\n   * @returns {Array<{ x: number, y: number, z?: number}>}\n   */\n  getLUT (steps) {\n    this.verify();\n    steps = steps || 100;\n\n    if (this._lut.length === steps) {\n      return this._lut;\n    }\n\n    this._lut = [];\n\n    // We want a range from 0 to 1 inclusive, so\n    // we decrement and then use <= rather than <:\n    steps--;\n    for (let t = 0; t <= steps; t++) {\n      this._lut.push(this.compute(t / steps));\n    }\n\n    return this._lut;\n  }\n\n  on (point, error) {\n    error = error || 5;\n    const lut = this.getLUT();\n    const hits = [];\n    let c;\n    let t = 0;\n\n    for (var i = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  /**\n   * Projects the {@code point} on to this curve.\n   *\n   * @param {{ x: number, y: number, z?: number }} point\n   * @returns {{ x: number, y: number, z?: number }}\n   */\n  project (point) {\n    // step 1: coarse check\n    const LUT = this.getLUT();\n    const l = LUT.length - 1;\n    const closest = utils.closest(LUT, point);\n    let mdist = closest.mdist;\n    const mpos = closest.mpos;\n\n    // step 2: fine check\n    var ft;\n    var t;\n    var p;\n    var d;\n    var t1 = (mpos - 1) / l;\n    var t2 = (mpos + 1) / l;\n    var step = 0.1 / l;\n    mdist += 1;\n    for (t = t1, ft = t; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n\n    return p;\n  }\n\n  /**\n   * @returns a {@code Bezier} curve with \"n + 1\" control points, where \"n\" is the number of control\n   *  points in this curve, equivalent to this curve.\n   */\n  raise () {\n    const p = this.points;\n    const np = [p[0]];\n    const k = p.length;\n    let pi;\n    let pim;\n\n    for (let i = 1; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: (k - i) / k * pi.x + i / k * pim.x,\n        y: (k - i) / k * pi.y + i / k * pim.y\n      };\n    }\n\n    np[k] = p[k - 1];\n\n    return new Bezier(np);\n  }\n\n  /**\n   * Calculates the arc length of this curve in the interval t âˆŠ [0,1].\n   */\n  length () {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  /**\n   * Calculates the tangent vector to this curve at {@code t}. This is equivalent to computing the derivative\n   * curve at {@code t}.\n   *\n   * @param {number} t\n   * @returns {{ x: number, y: number, z?: number }}\n   * @see https://pomax.github.io/bezierinfo/#derivatives\n   */\n  derivative = (t) => {\n    const mt = 1 - t;\n    let a;\n    let b;\n    let c = 0;\n    let p = this.dpoints[0];\n\n    if (this.order === 2) {\n      p = [p[0], p[1], ZERO];\n      a = mt;\n      b = t;\n    }\n    if (this.order === 3) {\n      a = mt * mt;\n      b = mt * t * 2;\n      c = t * t;\n    }\n\n    const ret = {\n      x: a * p[0].x + b * p[1].x + c * p[2].x,\n      y: a * p[0].y + b * p[1].y + c * p[2].y\n    };\n    if (this._3d) {\n      ret.z = a * p[0].z + b * p[1].z + c * p[2].z;\n    }\n\n    return ret;\n  }\n\n  curvature (t) {\n    return utils.curvature(t, this.points, this._3d);\n  }\n\n  inflections () {\n    return utils.inflections(this.points);\n  }\n\n  normal (t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  /**\n   * @private\n   */\n  __normal2 (t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n\n    return { x: -d.y / q, y: d.x / q };\n  }\n\n  /**\n   * @private\n   */\n  __normal3 (t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t);\n    const r2 = this.derivative(t + 0.01);\n    const q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z);\n    const q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z\n    ];\n\n    // normal vector:\n    const n = {\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z\n    };\n\n    return n;\n  }\n\n  hull (t) {\n    let p = this.points;\n    let _p = [];\n    let pt;\n    const q = [];\n    let idx = 0;\n    let i = 0;\n    let l = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (i = 0, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n\n    return q;\n  }\n\n  /**\n   * Splits the bezier curve\n   *\n   * + If both {@code t1} and {@code t2} are provided, the curve spanning between the two parameters is returned.\n   * + If only {@code t1} is passed, then an both the left (from 0 to {@code t1}) and right (from {@code t1} to 1)\n   *    curves are returned.\n   *\n   * @param {number} t1\n   * @param {number} t2\n   * @returns {Bezier | {\n   *  left: Bezier,\n   *  right: Bezier,\n   *  span: number\n   * }}\n   */\n  split (t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    var q = this.hull(t1);\n    var result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    const subsplit = result.right.split(t2);\n\n    return subsplit.left;\n  }\n\n  extrema () {\n    const dims = this.dims;\n    const result = {};\n    let roots = [];\n    let p;\n    let mfn;\n\n    dims.forEach(\n      function (dim) {\n        mfn = function (v) {\n          return v[dim];\n        };\n        p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    roots = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    result.values = roots;\n\n    return result;\n  }\n\n  bbox () {\n    const extrema = this.extrema();\n    const result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n\n    return result;\n  }\n\n  overlaps (curve) {\n    const lbbox = this.bbox();\n    const tbbox = curve.bbox();\n\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset (t, d) {\n    if (typeof d !== 'undefined') {\n      var c = this.get(t);\n      var n = this.normal(t);\n      var ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n\n    if (this._linear) {\n      var nv = this.normal(0);\n      var coords = this.points.map(function (p) {\n        var ret = {\n          x: p.x + t * nv.x,\n          y: p.y + t * nv.y\n        };\n        if (p.z && n.z) {\n          ret.z = p.z + t * nv.z;\n        }\n        return ret;\n      });\n      return [new Bezier(coords)];\n    }\n\n    const reduced = this.reduce();\n\n    return reduced.map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  /**\n   * @returns {boolean} whether this curve is \"simple\"\n   */\n  simple () {\n    if (this.order === 3) {\n      var a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      var a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n\n    const angle = abs(acos(s));\n\n    return angle < pi / 3;\n  }\n\n  reduce () {\n    var i;\n    var t1 = 0;\n    var t2 = 0;\n    var step = 0.01;\n    var segment;\n    var pass1 = [];\n    var pass2 = [];\n    // first pass: split on extrema\n    var extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  scale (d) {\n    var order = this.order;\n    var distanceFn = false;\n    if (typeof d === 'function') {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for degenerate (=linear) curves.\n    var clockwise = this.clockwise;\n    var r1 = distanceFn ? distanceFn(0) : d;\n    var r2 = distanceFn ? distanceFn(1) : d;\n    var v = [this.offset(0, 10), this.offset(1, 10)];\n    var o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n    if (!o) {\n      throw new Error('cannot scale this curve. Try reducing it first.');\n    }\n    // move all points by distance 'd' wrt the origin 'o'\n    var points = this.points;\n    var np = [];\n\n    // move end points by fixed distance along normal.\n    [0, 1].forEach(\n      function (t) {\n        var p = (np[t * order] = utils.copy(points[t * order]));\n        p.x += (t ? r2 : r1) * v[t].n.x;\n        p.y += (t ? r2 : r1) * v[t].n.y;\n      }\n    );\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach(\n        function (t) {\n          if (this.order === 2 && !!t) return;\n          var p = np[t * order];\n          var d = this.derivative(t);\n          var p2 = { x: p.x + d.x, y: p.y + d.y };\n          np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n        }.bind(this)\n      );\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(\n      function (t) {\n        if (this.order === 2 && !!t) return;\n        var p = points[t + 1];\n        var ov = {\n          x: p.x - o.x,\n          y: p.y - o.y\n        };\n        var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n        if (distanceFn && !clockwise) rc = -rc;\n        var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n        ov.x /= m;\n        ov.y /= m;\n        np[t + 1] = {\n          x: p.x + rc * ov.x,\n          y: p.y + rc * ov.y\n        };\n      }.bind(this)\n    );\n\n    return new Bezier(np);\n  }\n\n  outline (d1, d2, d3, d4) {\n    d2 = typeof d2 === 'undefined' ? d1 : d2;\n    var reduced = this.reduce();\n    var len = reduced.length;\n    var fcurves = [];\n    var bcurves = [];\n    var p;\n    var alen = 0;\n    var tlen = this.length();\n\n    var graduated = typeof d3 !== 'undefined' && typeof d4 !== 'undefined';\n\n    function linearDistanceFunction (s, e, tlen, alen, slen) {\n      return function (v) {\n        var f1 = alen / tlen;\n        var f2 = (alen + slen) / tlen;\n        var d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    var fs = fcurves[0].points[0];\n    var fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1];\n    var bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1];\n    var be = bcurves[0].points[0];\n    var ls = utils.makeline(bs, fs);\n    var le = utils.makeline(fe, be);\n    var segments = [ls]\n      .concat(fcurves)\n      .concat([le])\n      .concat(bcurves);\n    var slen = segments.length;\n\n    return new PolyBezier(segments);\n  }\n\n  /**\n   * @private\n   */\n  outlineshapes (d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    var outline = this.outline(d1, d2).curves;\n    var shapes = [];\n    for (var i = 1, len = outline.length; i < len / 2; i++) {\n      var shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  /**\n   *\n   * @param {Bezier}[curve=this]\n   * @param {number} curveIntersectionThreshold\n   */\n  intersects (curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects (line) {\n    var mx = min(line.p1.x, line.p2.x);\n    var my = min(line.p1.y, line.p2.y);\n    var MX = max(line.p1.x, line.p2.x);\n    var MY = max(line.p1.y, line.p2.y);\n    var self = this;\n    return utils.roots(this.points, line).filter(function (t) {\n      var p = self.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects (curveIntersectionThreshold) {\n    var reduced = this.reduce();\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n    var i;\n    var len = reduced.length - 2;\n    var results = [];\n    var result;\n    var left;\n    var right;\n    for (i = 0; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results = results.concat(result);\n    }\n    return results;\n  }\n\n  curveintersects (c1, c2, curveIntersectionThreshold) {\n    var pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    var intersections = [];\n    pairs.forEach(function (pair) {\n      var result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs (errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    var circles = [];\n    return this._iterate(errorThreshold, circles);\n  }\n\n  /**\n   * @private\n   */\n  _error (pc, np1, s, e) {\n    var q = (e - s) / 4;\n    var c1 = this.get(s + q);\n    var c2 = this.get(e - q);\n    var ref = utils.dist(pc, np1);\n    var d1 = utils.dist(pc, c1);\n    var d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate (errorThreshold, circles) {\n    /* eslint-disable camelcase */\n    var t_s = 0;\n    var t_e = 1;\n    var safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      var np1 = this.get(t_s);\n      var np2;\n      var np3;\n      var arc;\n      var prev_arc;\n\n      // booleans:\n      var curr_good = false;\n      var prev_good = false;\n      var done;\n\n      // numbers:\n      var t_m = t_e;\n      var prev_e = 1;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        // also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e\n        };\n\n        var error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              var d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e)\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc || arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n\n    /* eslint-enable camelcase */\n    return circles;\n  }\n\n  getUtils () {\n    return utils;\n  }\n\n  valueOf () {\n    return this.toString();\n  }\n\n  /**\n   * @returns a string representation of this bezier\n   */\n  toString () {\n    return utils.pointsToString(this.points);\n  }\n\n  /**\n   * @returns {string | boolean} - SVG string to draw this curve; {@code false} is returned for curves\n   *  in 3-space because they are not supported.\n   */\n  toSVG () {\n    if (this._3d) {\n      return false;\n    }\n\n    var p = this.points;\n    var x = p[0].x;\n    var y = p[0].y;\n    var s = ['M', x, y, this.order === 2 ? 'Q' : 'C'];\n\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n\n    return s.join(' ');\n  }\n\n  /**\n   * @private\n   */\n  verify () {\n    const print = this.coordDigest();\n\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  /**\n   * @private\n   */\n  coordDigest () {\n    return this.points\n      .map((controlPoint, i) => '' + i + controlPoint.x + controlPoint.y + (controlPoint.z || 0))\n      .join('');\n  }\n\n  /**\n   * This should be invoked whenever data has been modified. It will invalidate any caches (including the\n   * lookup tables) and does some recalculations.\n   *\n   * @private\n   * @param {} newprint - unused parameter?\n   */\n  update (newprint) {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection () {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n\n    this.clockwise = angle > 0;\n  }\n\n  /**\n   * turn an svg <path> d attribute into a sequence of Bezier segments.\n   */\n  static SVGtoBeziers (d) {\n    return svgToBeziers(Bezier, d);\n  }\n\n  static quadraticFromPoints (p1, p2, p3, t) {\n    if (typeof t === 'undefined') {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    var abc = getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints (S, B, E, t, d1) {\n    if (typeof t === 'undefined') {\n      t = 0.5;\n    }\n    var abc = getABC(3, S, B, E, t);\n    if (typeof d1 === 'undefined') {\n      d1 = utils.dist(B, abc.C);\n    }\n    var d2 = d1 * (1 - t) / t;\n\n    var selen = utils.dist(S, E);\n    var lx = (E.x - S.x) / selen;\n    var ly = (E.y - S.y) / selen;\n    var bx1 = d1 * lx;\n    var by1 = d1 * ly;\n    var bx2 = d2 * lx;\n    var by2 = d2 * ly;\n    // derivation of new hull coordinates\n    var e1 = { x: B.x - bx1, y: B.y - by1 };\n    var e2 = { x: B.x + bx2, y: B.y + by2 };\n    var A = abc.A;\n    var v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) };\n    var v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t };\n    var nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t };\n    var nc2 = {\n      x: E.x + (v2.x - E.x) / (1 - t),\n      y: E.y + (v2.y - E.y) / (1 - t)\n    };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  };\n\n  static getUtils () {\n    return utils;\n  }\n\n  static PolyBezier = PolyBezier;\n}\n"],"names":["abs","Math","cos","sin","acos","atan2","sqrt","pow","crt","v","pi","PI","tau","quart","nMax","Number","MAX_SAFE_INTEGER","nMin","MIN_SAFE_INTEGER","ZERO","x","y","z","utils","Tvalues","Cvalues","arcfn","t","derivativeFn","d","l","compute","points","_3d","order","length","p","mt","ret","a","b","c","mt2","t2","dCpts","JSON","parse","stringify","i","splice","computeWithRatios","ratios","r","f1","f2","f3","f4","derive","dpoints","list","Array","j","dpt","push","between","m","M","approximately","precision","sum","len","map","ds","de","ts","te","lerp","v1","v2","pointToString","s","pointsToString","join","copy","obj","angle","o","dx1","dy1","dx2","dy2","round","pos","indexOf","parseFloat","substring","dist","p1","p2","dx","dy","closest","LUT","point","mpos","mdist","forEach","idx","abcratio","n","bottom","projectionratio","top","lli8","x1","y1","x2","y2","x3","y3","x4","y4","lli4","p3","p4","lli","makeline","Bezier","findbbox","sections","mx","my","MX","MY","bbox","min","max","mid","size","shapeintersections","s1","bbox1","s2","bbox2","curveIntersectionThreshold","bboxoverlap","intersections","a1","startcap","forward","back","endcap","a2","l1","virtual","l2","iss","intersects","c1","c2","makeshape","bpl","fpl","start","end","shape","self","getminmax","curve","concat","get","align","line","tx","ty","roots","reduce","m1","m2","filter","pa","pb","pc","q","u1","q2","discriminant","mp3","phi","t1","sd","droots","curvature","kOnly","num","dnm","adk","dk","k","d1","d2","dd","qdsum","pk","nk","inflections","slice","v3","trm","sq","b1","b2","dim","dims","expandbox","_bbox","pairiteration","c1b","c2b","threshold","_t1","_t2","cc1","split","cc2","pairs","left","right","pair","results","getccenter","_","dx1p","dy1p","dx2p","dy2p","mx1","my1","mx2","my2","mx1n","my1n","mx2n","my2n","arc","e","numberSort","PolyBezier","curves","this","toString","offset","makeBezier","term","values","cvalues","bind","apply","last","convertPath","segment","terms","instruction","op","lop","alen","instructions","replace","instructionLength","args","sx","sy","cx","cy","cx2","cy2","normalized","toLowerCase","trim","normalise","matcher","RegExp","segments","ARGS","C","Q","L","test","VECTOR3_COMPONENTS","getABC","S","B","E","u","um","A","coords","_this","call","arguments","coordlen","_typeof","newargs","higher","Error","step","dimlen","_linear","update","_lut","steps","verify","error","lut","getLUT","hits","ft","pim","np","derivative","__normal3","__normal2","r1","r2","q1","R","pt","_p","hull","result","span","mfn","sort","extrema","lbbox","tbbox","normal","nv","scale","n1","n2","pass1","pass2","simple","distanceFn","raise","clockwise","ov","rc","d3","d4","reduced","fcurves","bcurves","tlen","graduated","linearDistanceFunction","slen","reverse","fs","fe","bs","be","ls","le","outline","shapes","lineIntersects","curveintersects","selfintersects","overlaps","errorThreshold","_iterate","np1","ref","circles","safety","t_s","t_e","np2","np3","prev_arc","done","curr_good","prev_good","t_m","prev_e","interval","_error","print","coordDigest","_print","controlPoint","newprint","computedirection","svgToBeziers","abc","selen","lx","ly","bx1","by1","bx2","by2","e1","e2"],"mappings":";;;;;;;8rBAGA,IAAMA,EAAMC,KAAKD,IACXE,EAAMD,KAAKC,IACXC,EAAMF,KAAKE,IACXC,EAAOH,KAAKG,KACZC,EAAQJ,KAAKI,MACbC,EAAOL,KAAKK,KACZC,EAAMN,KAAKM,IAEXC,EAAM,SAAUC,UACbA,EAAI,GAAKF,GAAKE,EAAG,EAAI,GAAKF,EAAIE,EAAG,EAAI,IAGxCC,EAAKT,KAAKU,GACVC,EAAM,EAAIF,EACVG,EAAQH,EAAK,EAIbI,EAAOC,OAAOC,kBAAoB,iBAClCC,EAAOF,OAAOG,mBAAqB,iBAEnCC,EAAO,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAMxBC,EAAQ,CAEZC,QAAS,EACN,mBACD,oBACC,kBACD,mBACC,kBACD,mBACC,kBACD,mBACC,kBACD,mBACC,kBACD,mBACC,kBACD,mBACC,iBACD,kBACC,kBACD,mBACC,kBACD,mBACC,kBACD,mBACC,kBACD,mBAIFC,QAAS,CACP,mBACA,mBACA,kBACA,kBACA,mBACA,mBACA,kBACA,kBACA,mBACA,mBACA,mBACA,mBACA,mBACA,mBACA,kBACA,kBACA,mBACA,mBACA,mBACA,mBACA,oBACA,oBACA,kBACA,mBAGFC,eAAOC,EAAGC,OACJC,EAAID,EAAaD,GACjBG,EAAID,EAAET,EAAIS,EAAET,EAAIS,EAAER,EAAIQ,EAAER,cACT,IAARQ,EAAEP,IACXQ,GAAKD,EAAEP,EAAIO,EAAEP,GAERhB,EAAKwB,IAUdC,iBAASJ,EAAGK,EAAQC,MAER,IAANN,SACKK,EAAO,OAGVE,EAAQF,EAAOG,OAAS,KAEpB,IAANR,SACKK,EAAOE,OAGZE,EAAIJ,EACFK,EAAK,EAAIV,KAGD,IAAVO,SACKF,EAAO,MAIF,IAAVE,EAAa,KACTI,EAAM,CACVlB,EAAGiB,EAAKD,EAAE,GAAGhB,EAAIO,EAAIS,EAAE,GAAGhB,EAC1BC,EAAGgB,EAAKD,EAAE,GAAGf,EAAIM,EAAIS,EAAE,GAAGf,UAExBY,IACFK,EAAIhB,EAAIe,EAAKD,EAAE,GAAGd,EAAIK,EAAIS,EAAE,GAAGd,GAG1BgB,KAILJ,EAAQ,EAAG,KAGTK,EACAC,EACAC,EAJEC,EAAML,EAAKA,EACXM,EAAKhB,EAAIA,EAIXE,EAAI,EACM,IAAVK,GACFE,EAAI,CAACA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIjB,GACvBoB,EAAIG,EACJF,EAAIH,EAAKV,EAAI,EACbc,EAAIE,GACe,IAAVT,IACTK,EAAIG,EAAML,EACVG,EAAIE,EAAMf,EAAI,EACdc,EAAIJ,EAAKM,EAAK,EACdd,EAAIF,EAAIgB,OAEJL,EAAM,CACVlB,EAAGmB,EAAIH,EAAE,GAAGhB,EAAIoB,EAAIJ,EAAE,GAAGhB,EAAIqB,EAAIL,EAAE,GAAGhB,EAAIS,EAAIO,EAAE,GAAGhB,EACnDC,EAAGkB,EAAIH,EAAE,GAAGf,EAAImB,EAAIJ,EAAE,GAAGf,EAAIoB,EAAIL,EAAE,GAAGf,EAAIQ,EAAIO,EAAE,GAAGf,UAEjDY,IACFK,EAAIhB,EAAIiB,EAAIH,EAAE,GAAGd,EAAIkB,EAAIJ,EAAE,GAAGd,EAAImB,EAAIL,EAAE,GAAGd,EAAIO,EAAIO,EAAE,GAAGd,GAGnDgB,UAILM,EAAQC,KAAKC,MAAMD,KAAKE,UAAUf,IAC/BY,EAAMT,OAAS,GAAG,KAClB,IAAIa,EAAI,EAAGA,EAAIJ,EAAMT,OAAS,EAAGa,IACpCJ,EAAMI,GAAK,CACT5B,EAAGwB,EAAMI,GAAG5B,GAAKwB,EAAMI,EAAI,GAAG5B,EAAIwB,EAAMI,GAAG5B,GAAKO,EAChDN,EAAGuB,EAAMI,GAAG3B,GAAKuB,EAAMI,EAAI,GAAG3B,EAAIuB,EAAMI,GAAG3B,GAAKM,QAExB,IAAfiB,EAAMI,GAAG1B,IAClBsB,EAAMI,GAAKJ,EAAMI,GAAG1B,GAAKsB,EAAMI,EAAI,GAAG1B,EAAIsB,EAAMI,GAAG1B,GAAKK,GAG5DiB,EAAMK,OAAOL,EAAMT,OAAS,EAAG,UAG1BS,EAAM,IAYfM,2BAAmBvB,EAAGK,EAAQmB,EAAQlB,OAIhCJ,EAHEQ,EAAK,EAAIV,EACTyB,EAAID,EACJf,EAAIJ,EAENqB,EAAKD,EAAE,GAAQE,EAAKF,EAAE,GAAQG,EAAKH,EAAE,GAAQI,EAAKJ,EAAE,UAGxDC,GAAMhB,EACNiB,GAAM3B,EAEW,IAAbS,EAAED,QACJN,EAAIwB,EAAKC,EACF,CACLlC,GAAIiC,EAAKjB,EAAE,GAAGhB,EAAIkC,EAAKlB,EAAE,GAAGhB,GAAKS,EACjCR,GAAIgC,EAAKjB,EAAE,GAAGf,EAAIiC,EAAKlB,EAAE,GAAGf,GAAKQ,EACjCP,IAAIW,IAAeoB,EAAKjB,EAAE,GAAGd,EAAIgC,EAAKlB,EAAE,GAAGd,GAAKO,KAKpDwB,GAAMhB,EACNiB,GAAM,EAAIjB,EACVkB,GAAM5B,EAAIA,EAEO,IAAbS,EAAED,QACJN,EAAIwB,EAAKC,EAAKC,EACP,CACLnC,GAAIiC,EAAKjB,EAAE,GAAGhB,EAAIkC,EAAKlB,EAAE,GAAGhB,EAAImC,EAAKnB,EAAE,GAAGhB,GAAKS,EAC/CR,GAAIgC,EAAKjB,EAAE,GAAGf,EAAIiC,EAAKlB,EAAE,GAAGf,EAAIkC,EAAKnB,EAAE,GAAGf,GAAKQ,EAC/CP,IAAIW,IAAeoB,EAAKjB,EAAE,GAAGd,EAAIgC,EAAKlB,EAAE,GAAGd,EAAIiC,EAAKnB,EAAE,GAAGd,GAAKO,KAKlEwB,GAAMhB,EACNiB,GAAM,IAAMjB,EACZkB,GAAM,EAAIlB,EACVmB,GAAM7B,EAAIA,EAAIA,EAEG,IAAbS,EAAED,QACJN,EAAIwB,EAAKC,EAAKC,EAAKC,EAEZ,CACLpC,GAAIiC,EAAKjB,EAAE,GAAGhB,EAAIkC,EAAKlB,EAAE,GAAGhB,EAAImC,EAAKnB,EAAE,GAAGhB,EAAIoC,EAAKpB,EAAE,GAAGhB,GAAKS,EAC7DR,GAAIgC,EAAKjB,EAAE,GAAGf,EAAIiC,EAAKlB,EAAE,GAAGf,EAAIkC,EAAKnB,EAAE,GAAGf,EAAImC,EAAKpB,EAAE,GAAGf,GAAKQ,EAC7DP,IAAIW,IAAeoB,EAAKjB,EAAE,GAAGd,EAAIgC,EAAKlB,EAAE,GAAGd,EAAIiC,EAAKnB,EAAE,GAAGd,EAAIkC,EAAKpB,EAAE,GAAGd,GAAKO,cAelF4B,gBAAQzB,EAAQC,WACRyB,EAAU,GAEZtB,EAAIJ,EACJH,EAAIO,EAAED,OACNM,EAAIZ,EAAI,EAELA,EAAI,EAAGA,IAAKY,IAAK,SAChBkB,EAAO,IAAIC,MAAMnB,GAEdoB,EAAI,EAAGA,EAAIpB,EAAGoB,IAAK,KACpBC,EAAM,CACV1C,EAAGqB,GAAKL,EAAEyB,EAAI,GAAGzC,EAAIgB,EAAEyB,GAAGzC,GAC1BC,EAAGoB,GAAKL,EAAEyB,EAAI,GAAGxC,EAAIe,EAAEyB,GAAGxC,IAExBY,IACF6B,EAAIxC,EAAImB,GAAKL,EAAEyB,EAAI,GAAGvC,EAAIc,EAAEyB,GAAGvC,IAGjCqC,EAAKE,GAAKC,EAGZJ,EAAQK,KAAKJ,GACbvB,EAAIuB,SAGCD,GAGTM,iBAASvD,EAAGwD,EAAGC,UAEVD,GAAKxD,GAAKA,GAAKyD,GAChB3C,EAAM4C,cAAc1D,EAAGwD,IACvB1C,EAAM4C,cAAc1D,EAAGyD,IAI3BC,uBAAe5B,EAAGC,EAAG4B,UACZpE,EAAIuC,EAAIC,KAAO4B,GAjRV,OAoRdjC,gBAAQP,OAIFoB,EACArB,EAHA0C,EAAM,EACNC,EAAM/C,EAAMC,QAAQW,WAGnBa,EAAI,EAAGA,EAAIsB,EAAKtB,IACnBrB,EANM,GAMEJ,EAAMC,QAAQwB,GANhB,GAONqB,GAAO9C,EAAME,QAAQuB,GAAKzB,EAAMG,MAAMC,EAAGC,SAPnC,GASGyC,GAGbE,aAAK9D,EAAG+D,EAAIC,EAAIC,EAAIC,UAKXD,GAHEC,EAAKD,KACLjE,EAAI+D,IAFJC,EAAKD,KAOhBI,cAAMxB,EAAGyB,EAAIC,OACPxC,EAAM,CACRlB,EAAGyD,EAAGzD,EAAIgC,GAAK0B,EAAG1D,EAAIyD,EAAGzD,GACzBC,EAAGwD,EAAGxD,EAAI+B,GAAK0B,EAAGzD,EAAIwD,EAAGxD,WAErBwD,EAAGvD,GAAOwD,EAAGxD,IACjBgB,EAAIhB,EAAIuD,EAAGvD,EAAI8B,GAAK0B,EAAGxD,EAAIuD,EAAGvD,IAEzBgB,GAGTyC,uBAAe3C,OACT4C,EAAI5C,EAAEhB,EAAI,IAAMgB,EAAEf,cACH,IAARe,EAAEd,IACX0D,GAAK,IAAM5C,EAAEd,GAER0D,GAGTC,wBAAgBjD,SACP,IAAMA,EAAOuC,IAAIhD,EAAMwD,eAAeG,KAAK,MAAQ,KAG5DC,cAAMC,UACGvC,KAAKC,MAAMD,KAAKE,UAAUqC,KAGnCC,eAAOC,EAAGT,EAAIC,OACRS,EAAMV,EAAGzD,EAAIkE,EAAElE,EACfoE,EAAMX,EAAGxD,EAAIiE,EAAEjE,EACfoE,EAAMX,EAAG1D,EAAIkE,EAAElE,EACfsE,EAAMZ,EAAGzD,EAAIiE,EAAEjE,SAGZhB,EAFKkF,EAAMG,EAAMF,EAAMC,EACpBF,EAAME,EAAMD,EAAME,IAK9BC,eAAOlF,EAAGoB,OACJmD,EAAI,GAAKvE,EACTmF,EAAMZ,EAAEa,QAAQ,YACbC,WAAWd,EAAEe,UAAU,EAAGH,EAAM,EAAI/D,KAG7CmE,cAAMC,EAAIC,OACJC,EAAKF,EAAG7E,EAAI8E,EAAG9E,EACfgF,EAAKH,EAAG5E,EAAI6E,EAAG7E,SACZf,EAAK6F,EAAKA,EAAKC,EAAKA,IAG7BC,iBAASC,EAAKC,OAERC,EACA3E,EAFA4E,EAAQlG,EAAI,EAAG,WAGnB+F,EAAII,SAAQ,SAAUtE,EAAGuE,IACvB9E,EAAIN,EAAMyE,KAAKO,EAAOnE,IACdqE,IACNA,EAAQ5E,EACR2E,EAAOG,MAGJ,CAAEF,MAAOA,EAAOD,KAAMA,IAG/BI,kBAAUjF,EAAGkF,MAED,IAANA,GAAiB,IAANA,SACN,UAEQ,IAANlF,EACTA,EAAI,QACC,GAAU,IAANA,GAAiB,IAANA,SACbA,MAELmF,EAASvG,EAAIoB,EAAGkF,GAAKtG,EAAI,EAAIoB,EAAGkF,UAE7B7G,GADG8G,EAAS,GACFA,IAGnBC,yBAAiBpF,EAAGkF,MAER,IAANA,GAAiB,IAANA,SACN,UAEQ,IAANlF,EACTA,EAAI,QACC,GAAU,IAANA,GAAiB,IAANA,SACbA,MAELqF,EAAMzG,EAAI,EAAIoB,EAAGkF,UAEdG,GADMzG,EAAIoB,EAAGkF,GAAKG,IAI3BC,cAAMC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,EAAIC,OAG1B5F,GAAKqF,EAAKE,IAAOG,EAAKE,IAAON,EAAKE,IAAOC,EAAKE,UAE1C,IAAN3F,GAIG,CAAET,IARG8F,EAAKG,EAAKF,EAAKC,IAAOE,EAAKE,IAAON,EAAKE,IAAOE,EAAKG,EAAKF,EAAKC,IAQxD3F,EAAGR,IAPR6F,EAAKG,EAAKF,EAAKC,IAAOG,EAAKE,IAAON,EAAKE,IAAOC,EAAKG,EAAKF,EAAKC,IAO7C3F,IAG9B6F,cAAMzB,EAAIC,EAAIyB,EAAIC,UACTrG,EAAM0F,KACXhB,EAAG7E,EAAG6E,EAAG5E,EACT6E,EAAG9E,EAAG8E,EAAG7E,EACTsG,EAAGvG,EAAGuG,EAAGtG,EACTuG,EAAGxG,EAAGwG,EAAGvG,IAGbwG,aAAKhD,EAAIC,UACAvD,EAAMmG,KAAK7C,EAAIA,EAAGpC,EAAGqC,EAAIA,EAAGrC,IAGrCqF,kBAAU7B,EAAIC,OACRgB,EAAKjB,EAAG7E,EACR+F,EAAKlB,EAAG5E,EACR+F,EAAKlB,EAAG9E,EACRiG,EAAKnB,EAAG7E,EACR8E,GAAMiB,EAAKF,GAAM,EACjBd,GAAMiB,EAAKF,GAAM,SACd,IAAIY,EACTb,EACAC,EACAD,EAAKf,EACLgB,EAAKf,EACLc,EAAK,EAAIf,EACTgB,EAAK,EAAIf,EACTgB,EACAC,IAIJW,kBAAUC,OACJC,EAAKpH,EACLqH,EAAKrH,EACLsH,EAAKnH,EACLoH,EAAKpH,SACTgH,EAASvB,SAAQ,SAAU1B,OACrBsD,EAAOtD,EAAEsD,OACTJ,EAAKI,EAAKlH,EAAEmH,MAAKL,EAAKI,EAAKlH,EAAEmH,KAC7BJ,EAAKG,EAAKjH,EAAEkH,MAAKJ,EAAKG,EAAKjH,EAAEkH,KAC7BH,EAAKE,EAAKlH,EAAEoH,MAAKJ,EAAKE,EAAKlH,EAAEoH,KAC7BH,EAAKC,EAAKjH,EAAEmH,MAAKH,EAAKC,EAAKjH,EAAEmH,QAE5B,CACLpH,EAAG,CAAEmH,IAAKL,EAAIO,KAAMP,EAAKE,GAAM,EAAGI,IAAKJ,EAAIM,KAAMN,EAAKF,GACtD7G,EAAG,CAAEkH,IAAKJ,EAAIM,KAAMN,EAAKE,GAAM,EAAGG,IAAKH,EAAIK,KAAML,EAAKF,KAI1DQ,4BACEC,EACAC,EACAC,EACAC,EACAC,OAEKzH,EAAM0H,YAAYJ,EAAOE,GAAQ,MAAO,OACzCG,EAAgB,GAChBC,EAAK,CAACP,EAAGQ,SAAUR,EAAGS,QAAST,EAAGU,KAAMV,EAAGW,QAC3CC,EAAK,CAACV,EAAGM,SAAUN,EAAGO,QAASP,EAAGQ,KAAMR,EAAGS,eAC/CJ,EAAGzC,SAAQ,SAAU+C,GACfA,EAAGC,SACPF,EAAG9C,SAAQ,SAAUiD,OACfA,EAAGD,aACHE,EAAMH,EAAGI,WAAWF,EAAIX,GACxBY,EAAIzH,OAAS,IACfyH,EAAIE,GAAKL,EACTG,EAAIG,GAAKJ,EACTC,EAAIhB,GAAKA,EACTgB,EAAId,GAAKA,EACTI,EAAcnF,KAAK6F,WAIlBV,GAGTc,mBAAWX,EAASC,EAAMN,OACpBiB,EAAMX,EAAKtH,OAAOG,OAClB+H,EAAMb,EAAQrH,OAAOG,OACrBgI,EAAQ5I,EAAMuG,SAASwB,EAAKtH,OAAOiI,EAAM,GAAIZ,EAAQrH,OAAO,IAC5DoI,EAAM7I,EAAMuG,SAASuB,EAAQrH,OAAOkI,EAAM,GAAIZ,EAAKtH,OAAO,IAC1DqI,EAAQ,CACVjB,SAAUe,EACVd,QAASA,EACTC,KAAMA,EACNC,OAAQa,EACR9B,KAAM/G,EAAMyG,SAAS,CAACmC,EAAOd,EAASC,EAAMc,KAE1CE,EAAO/I,SACX8I,EAAMnB,cAAgB,SAAUJ,UACvBwB,EAAK3B,mBACV0B,EACAA,EAAM/B,KACNQ,EACAA,EAAGR,KACHU,IAGGqB,GAGTE,mBAAWC,EAAO3I,EAAG8B,OACdA,EAAM,MAAO,CAAE4E,IAAK,EAAGC,IAAK,OAG7B7G,EACAc,EAHA8F,EAAMzH,EACN0H,EAAMvH,GAGe,IAArB0C,EAAKkC,QAAQ,KACflC,EAAO,CAAC,GAAG8G,OAAO9G,KAEK,IAArBA,EAAKkC,QAAQ,IACflC,EAAKI,KAAK,OAEP,IAAIf,EAAI,EAAGsB,EAAMX,EAAKxB,OAAQa,EAAIsB,EAAKtB,IAC1CrB,EAAIgC,EAAKX,IACTP,EAAI+H,EAAME,IAAI/I,IACRE,GAAK0G,IACTA,EAAM9F,EAAEZ,IAENY,EAAEZ,GAAK2G,IACTA,EAAM/F,EAAEZ,UAGL,CAAE0G,IAAKA,EAAKE,KAAMF,EAAMC,GAAO,EAAGA,IAAKA,EAAKE,KAAMF,EAAMD,IAGjEoC,eAAO3I,EAAQ4I,OACTC,EAAKD,EAAK3E,GAAG7E,EACb0J,EAAKF,EAAK3E,GAAG5E,EACbkB,GAAKlC,EAAMuK,EAAK1E,GAAG7E,EAAIyJ,EAAIF,EAAK1E,GAAG9E,EAAIyJ,UAOpC7I,EAAOuC,KANN,SAAU9D,SACT,CACLW,GAAIX,EAAEW,EAAIyJ,GAAM3K,EAAIqC,IAAM9B,EAAEY,EAAIyJ,GAAM3K,EAAIoC,GAC1ClB,GAAIZ,EAAEW,EAAIyJ,GAAM1K,EAAIoC,IAAM9B,EAAEY,EAAIyJ,GAAM5K,EAAIqC,QAMhDwI,eAAO/I,EAAQ4I,GACbA,EAAOA,GAAQ,CAAE3E,GAAI,CAAE7E,EAAG,EAAGC,EAAG,GAAK6E,GAAI,CAAE9E,EAAG,EAAGC,EAAG,QAC9Ca,EAAQF,EAAOG,OAAS,EAC1BC,EAAIb,EAAMoJ,MAAM3I,EAAQ4I,GAEtBI,EAAS,SAAUrJ,UAChBA,GAAK,GAAKA,GAAK,MAGV,IAAVO,EAAa,KACTK,EAAIH,EAAE,GAAGf,EACTmB,EAAIJ,EAAE,GAAGf,EACToB,EAAIL,EAAE,GAAGf,EACTQ,EAAIU,EAAI,EAAIC,EAAIC,KAEZ,IAANZ,EAAS,KACLoJ,GAAM3K,EAAKkC,EAAIA,EAAID,EAAIE,GACvByI,GAAM3I,EAAIC,QAIT,GAHMyI,EAAKC,GAAMrJ,KACVoJ,EAAKC,GAAMrJ,GAETsJ,OAAOH,GAClB,OAAIxI,IAAMC,GAAW,IAANZ,EACb,EAAE,EAAIW,EAAIC,IAAM,EAAID,EAAI,EAAIC,IAAI0I,OAAOH,GAGzC,OAILI,EAAKhJ,EAAE,GAAGf,EACVgK,EAAKjJ,EAAE,GAAGf,EACViK,EAAKlJ,EAAE,GAAGf,EAEVQ,EAAU,EAAIwJ,EAATD,EAAc,EAAIE,EADlBlJ,EAAE,GAAGf,EAEVkB,EAAI,EAAI6I,EAAK,EAAIC,EAAK,EAAIC,EAC1B9I,GAAK,EAAI4I,EAAK,EAAIC,EAClB5I,EAAI2I,KAEJ7J,EAAM4C,cAActC,EAAG,GAAI,IAEzBN,EAAM4C,cAAc5B,EAAG,UAErBhB,EAAM4C,cAAc3B,EAAG,GAElB,GAGF,EAAEC,EAAID,GAAG2I,OAAOH,OAGrBO,EAAIjL,EAAKkC,EAAIA,EAAI,EAAID,EAAIE,GACzB+G,EAAK,EAAIjH,QACN,EAAEgJ,EAAI/I,GAAKgH,IAAMhH,EAAI+I,GAAK/B,GAAI2B,OAAOH,OAa1CQ,EAJA7D,GADJvF,GAAK,GAHLI,GAAKX,IADLU,GAAKV,GAIYU,GAAK,GACT,EAETkJ,GADJF,GAAK,EAAIhJ,EAAIA,EAAIA,EAAI,EAAIA,EAAIC,EAAI,IAJjCC,GAAKZ,IAIsC,IAC9B,EACT6J,EAAeD,EAAKA,EAAK9D,EAAKA,EAAKA,KAOnC+D,EAAe,EAAG,KAChBC,GAAOvJ,EAAI,EAEXgB,EAAI9C,EADGqL,EAAMA,EAAMA,GAEnBhK,GAAK4J,GAAK,EAAInI,GAEdwI,EAAMxL,EADGuB,GAAK,GAAK,EAAIA,EAAI,EAAI,EAAIA,GAGnCkK,EAAK,EADErL,EAAI4C,SAMR,CAJFyI,EAAK3L,EAAI0L,EAAM,GAAKrJ,EAAI,EACxBsJ,EAAK3L,GAAK0L,EAAMhL,GAAO,GAAK2B,EAAI,EAChCsJ,EAAK3L,GAAK0L,EAAM,EAAIhL,GAAO,GAAK2B,EAAI,GAErB4I,OAAOH,GACtB,GAAqB,IAAjBU,QAKF,CAHF,GADLF,EAAKC,EAAK,EAAIjL,GAAKiL,IAAOjL,EAAIiL,IAChBlJ,EAAI,GACZiJ,EAAKjJ,EAAI,GAEC4I,OAAOH,OAEnBc,EAAKxL,EAAKoL,SAIP,EAHPF,EAAKhL,GAAKiL,EAAKK,IACVtL,EAAIiL,EAAKK,GAEIvJ,EAAI,GAAG4I,OAAOH,IAIpCe,gBAAQ3J,MAEW,IAAbA,EAAED,OAAc,KACdI,EAAIH,EAAE,GACNI,EAAIJ,EAAE,GACNK,EAAIL,EAAE,GACNP,EAAIU,EAAI,EAAIC,EAAIC,KACV,IAANZ,EAAS,KACPoJ,GAAM3K,EAAKkC,EAAIA,EAAID,EAAIE,GACvByI,GAAM3I,EAAIC,QAGP,GAFIyI,EAAKC,GAAMrJ,KACVoJ,EAAKC,GAAMrJ,GAElB,OAAIW,IAAMC,GAAW,IAANZ,EACb,EAAE,EAAIW,EAAIC,IAAM,GAAKD,EAAIC,KAE3B,MAIQ,IAAbL,EAAED,OAAc,KACZI,EAAIH,EAAE,GACNI,EAAIJ,EAAE,UAERG,IAAMC,EACD,CAACD,GAAKA,EAAIC,IAGZ,KAIXwJ,mBAAWrK,EAAGK,EAAQC,EAAKgK,OAIrBC,EAASC,EAASC,EAASC,EAAQC,EAAWlJ,EAH9CM,EAAUnC,EAAMkC,OAAOzB,GACvBuK,EAAK7I,EAAQ,GACb8I,EAAK9I,EAAQ,GAmBb7B,EAAIN,EAAMQ,QAAQJ,EAAG4K,GACrBE,EAAKlL,EAAMQ,QAAQJ,EAAG6K,GACtBE,EAAQ7K,EAAET,EAAIS,EAAET,EAAIS,EAAER,EAAIQ,EAAER,KAC5BY,GACFiK,EAAM5L,EACJC,EAAIsB,EAAER,EAAIoL,EAAGnL,EAAImL,EAAGpL,EAAIQ,EAAEP,EAAG,GAC7Bf,EAAIsB,EAAEP,EAAImL,EAAGrL,EAAIqL,EAAGnL,EAAIO,EAAET,EAAG,GAC7Bb,EAAIsB,EAAET,EAAIqL,EAAGpL,EAAIoL,EAAGrL,EAAIS,EAAER,EAAG,IAE/B8K,EAAM5L,EAAImM,EAAQ7K,EAAEP,EAAIO,EAAEP,EAAG,OAE7B4K,EAAMrK,EAAET,EAAIqL,EAAGpL,EAAIQ,EAAER,EAAIoL,EAAGrL,EAC5B+K,EAAM5L,EAAImM,EAAO,MAGP,IAARR,GAAqB,IAARC,QACR,CAAEG,EAAG,EAAGlJ,EAAG,MAGpBkJ,EAAIJ,EAAMC,EACV/I,EAAI+I,EAAMD,GAMLD,EAAO,KAGNU,EAAKpL,EAAMyK,UAAUrK,EAAI,KAAOK,EAAQC,GAAK,GAAMqK,EACnDM,EAAKrL,EAAMyK,UAAUrK,EAAI,KAAOK,EAAQC,GAAK,GAAMqK,EACvDD,GAAOO,EAAKN,GAAMA,EAAIK,IAAO,EAC7BP,GAAOpM,EAAI4M,EAAKN,GAAKtM,EAAIsM,EAAIK,IAAO,QAG/B,CAAEL,EAAGA,EAAGlJ,EAAGA,EAAGiJ,GAAIA,EAAID,IAAKA,IAGpCS,qBAAa7K,MACPA,EAAOG,OAAS,EAAG,MAAO,OAI1BC,EAAIb,EAAMoJ,MAAM3I,EAAQ,CAAEiE,GAAIjE,EAAO,GAAIkE,GAAIlE,EAAO8K,OAAO,GAAG,KAC9DvK,EAAIH,EAAE,GAAGhB,EAAIgB,EAAE,GAAGf,EAClBmB,EAAIJ,EAAE,GAAGhB,EAAIgB,EAAE,GAAGf,EAClBoB,EAAIL,EAAE,GAAGhB,EAAIgB,EAAE,GAAGf,EAClBQ,EAAIO,EAAE,GAAGhB,EAAIgB,EAAE,GAAGf,EAClBwD,EAAK,KAAO,EAAItC,EAAI,EAAIC,EAAI,EAAIC,EAAIZ,GACpCiD,EAAK,IAAM,EAAIvC,EAAIC,EAAI,EAAIC,GAC3BsK,EAAK,IAAMtK,EAAIF,MAEfhB,EAAM4C,cAAcU,EAAI,GAAI,KACzBtD,EAAM4C,cAAcW,EAAI,GAAI,KAC3BnD,GAAKoL,EAAKjI,KACVnD,GAAK,GAAKA,GAAK,EAAG,MAAO,CAACA,SAEzB,OAGLqL,EAAMlI,EAAKA,EAAK,EAAID,EAAKkI,EACzBE,EAAKhN,KAAKK,KAAK0M,UACnBnL,EAAI,EAAIgD,EAEJtD,EAAM4C,cAActC,EAAG,GAAW,GAE/B,EAAEoL,EAAKnI,GAAMjD,IAAKiD,EAAKmI,GAAMpL,GAAGsJ,QAAO,SAAU/H,UAC/CA,GAAK,GAAKA,GAAK,MAI1B6F,qBAAaiE,EAAIC,OAGXnK,EACAoK,EACAtL,EACAH,EACAE,EANAwL,EAAO,CAAC,IAAK,KACb/I,EAAM+I,EAAKlL,WAMVa,EAAI,EAAGA,EAAIsB,EAAKtB,OAEnBlB,EAAIoL,EADJE,EAAMC,EAAKrK,IACCyF,IACZ9G,EAAIwL,EAAGC,GAAK3E,IACZ5G,GAAKqL,EAAGE,GAAK1E,KAAOyE,EAAGC,GAAK1E,MAAQ,EAChC1I,EAAI8B,EAAIH,IAAME,EAAG,OAAO,SAEvB,GAGTyL,mBAAWhF,EAAMiF,GACXA,EAAMnM,EAAEmH,IAAMD,EAAKlH,EAAEmH,MACvBD,EAAKlH,EAAEmH,IAAMgF,EAAMnM,EAAEmH,KAEnBgF,EAAMlM,EAAEkH,IAAMD,EAAKjH,EAAEkH,MACvBD,EAAKjH,EAAEkH,IAAMgF,EAAMlM,EAAEkH,KAEnBgF,EAAMjM,GAAKiM,EAAMjM,EAAEiH,IAAMD,EAAKhH,EAAEiH,MAClCD,EAAKhH,EAAEiH,IAAMgF,EAAMjM,EAAEiH,KAEnBgF,EAAMnM,EAAEoH,IAAMF,EAAKlH,EAAEoH,MACvBF,EAAKlH,EAAEoH,IAAM+E,EAAMnM,EAAEoH,KAEnB+E,EAAMlM,EAAEmH,IAAMF,EAAKjH,EAAEmH,MACvBF,EAAKjH,EAAEmH,IAAM+E,EAAMlM,EAAEmH,KAEnB+E,EAAMjM,GAAKiM,EAAMjM,EAAEkH,IAAMF,EAAKhH,EAAEkH,MAClCF,EAAKhH,EAAEkH,IAAM+E,EAAMjM,EAAEkH,KAEvBF,EAAKlH,EAAEqH,KAAOH,EAAKlH,EAAEmH,IAAMD,EAAKlH,EAAEoH,KAAO,EACzCF,EAAKjH,EAAEoH,KAAOH,EAAKjH,EAAEkH,IAAMD,EAAKjH,EAAEmH,KAAO,EACrCF,EAAKhH,IACPgH,EAAKhH,EAAEmH,KAAOH,EAAKhH,EAAEiH,IAAMD,EAAKhH,EAAEkH,KAAO,GAE3CF,EAAKlH,EAAEsH,KAAOJ,EAAKlH,EAAEoH,IAAMF,EAAKlH,EAAEmH,IAClCD,EAAKjH,EAAEqH,KAAOJ,EAAKjH,EAAEmH,IAAMF,EAAKjH,EAAEkH,IAC9BD,EAAKhH,IACPgH,EAAKhH,EAAEoH,KAAOJ,EAAKhH,EAAEkH,IAAMF,EAAKhH,EAAEiH,MAItCiF,uBAAe1D,EAAIC,EAAIf,OACjByE,EAAM3D,EAAGxB,OACToF,EAAM3D,EAAGzB,OACTlF,EAAI,IACJuK,EAAY3E,GAA8B,MAE5CyE,EAAIrM,EAAEsH,KAAO+E,EAAIpM,EAAEqH,KAAOiF,GAC1BD,EAAItM,EAAEsH,KAAOgF,EAAIrM,EAAEqH,KAAOiF,QAEnB,EACHvK,GAAK0G,EAAG8D,IAAM9D,EAAG+D,KAAO,EAAK,GAAKzK,EAClC,KACEA,GAAK2G,EAAG6D,IAAM7D,EAAG8D,KAAO,EAAK,GAAKzK,OAGtC0K,EAAMhE,EAAGiE,MAAM,IACfC,EAAMjE,EAAGgE,MAAM,IACfE,EAAQ,CACV,CAAEC,KAAMJ,EAAII,KAAMC,MAAOH,EAAIE,MAC7B,CAAEA,KAAMJ,EAAII,KAAMC,MAAOH,EAAIG,OAC7B,CAAED,KAAMJ,EAAIK,MAAOA,MAAOH,EAAIG,OAC9B,CAAED,KAAMJ,EAAIK,MAAOA,MAAOH,EAAIE,OAEhCD,EAAQA,EAAM9C,QAAO,SAAUiD,UACtB7M,EAAM0H,YAAYmF,EAAKF,KAAK5F,OAAQ8F,EAAKD,MAAM7F,eAEpD+F,EAAU,UACO,IAAjBJ,EAAM9L,OAAqBkM,GAC/BJ,EAAMvH,SAAQ,SAAU0H,GACtBC,EAAUA,EAAQ5D,OAChBlJ,EAAMiM,cAAcY,EAAKF,KAAME,EAAKD,MAAOR,OAG/CU,EAAUA,EAAQlD,QAAO,SAAU1K,EAAGuC,UAC7BqL,EAAQxI,QAAQpF,KAAOuC,OAKlCsL,oBAAYrI,EAAIC,EAAIyB,OA0Bd4G,EAzBAhJ,EAAMW,EAAG9E,EAAI6E,EAAG7E,EAChBoE,EAAMU,EAAG7E,EAAI4E,EAAG5E,EAChBoE,EAAMkC,EAAGvG,EAAI8E,EAAG9E,EAChBsE,EAAMiC,EAAGtG,EAAI6E,EAAG7E,EAChBmN,EAAOjJ,EAAMrF,EAAIW,GAAS2E,EAAMrF,EAAIU,GACpC4N,EAAOlJ,EAAMpF,EAAIU,GAAS2E,EAAMtF,EAAIW,GACpC6N,EAAOjJ,EAAMvF,EAAIW,GAAS6E,EAAMvF,EAAIU,GACpC8N,EAAOlJ,EAAMtF,EAAIU,GAAS6E,EAAMxF,EAAIW,GAEpC+N,GAAO3I,EAAG7E,EAAI8E,EAAG9E,GAAK,EACtByN,GAAO5I,EAAG5E,EAAI6E,EAAG7E,GAAK,EACtByN,GAAO5I,EAAG9E,EAAIuG,EAAGvG,GAAK,EACtB2N,GAAO7I,EAAG7E,EAAIsG,EAAGtG,GAAK,EAEtB2N,EAAOJ,EAAMJ,EACbS,EAAOJ,EAAMJ,EACbS,EAAOJ,EAAMJ,EACbS,EAAOJ,EAAMJ,EAEbS,EAAM7N,EAAM0F,KAAK2H,EAAKC,EAAKG,EAAMC,EAAMH,EAAKC,EAAKG,EAAMC,GACvD/L,EAAI7B,EAAMyE,KAAKoJ,EAAKnJ,GAEpBjB,EAAI3E,EAAM4F,EAAG5E,EAAI+N,EAAI/N,EAAG4E,EAAG7E,EAAIgO,EAAIhO,GACnC6C,EAAI5D,EAAM6F,EAAG7E,EAAI+N,EAAI/N,EAAG6E,EAAG9E,EAAIgO,EAAIhO,GACnCiO,EAAIhP,EAAMsH,EAAGtG,EAAI+N,EAAI/N,EAAGsG,EAAGvG,EAAIgO,EAAIhO,UAGnC4D,EAAIqK,IAIFrK,EAAIf,GAAKA,EAAIoL,KACfrK,GAAKpE,GAEHoE,EAAIqK,IACNd,EAAIc,EACJA,EAAIrK,EACJA,EAAIuJ,IAMFc,EAAIpL,GAAKA,EAAIe,GACfuJ,EAAIc,EACJA,EAAIrK,EACJA,EAAIuJ,GAEJc,GAAKzO,EAITwO,EAAIpK,EAAIA,EACRoK,EAAIC,EAAIA,EACRD,EAAIhM,EAAIA,EACDgM,GAGTE,oBAAY/M,EAAGC,UACND,EAAIC,ICn6BF+M,wBAKEC,kBACNA,OAAS,QACTvN,KAAM,EAEPuN,SACGA,OAASA,OACTvN,IAAMwN,KAAKD,OAAO,GAAGvN,wDAKrBwN,KAAKC,oDAKV,IACAD,KAAKD,OACFjL,KAAI,SAAUiG,UACNjJ,EAAM0D,eAAeuF,EAAMxI,WAEnCkD,KAAK,MACR,qCAOMsF,QACHgF,OAAOzL,KAAKyG,QACZvI,IAAMwN,KAAKxN,KAAOuI,EAAMvI,4CAOtBwN,KAAKD,OACTjL,KAAI,SAAU9D,UACNA,EAAE0B,YAEV6I,QAAO,SAAUzI,EAAGC,UACZD,EAAIC,mCAIVmE,UACE8I,KAAKD,OAAO7I,0CAIflE,EAAIgN,KAAKD,OACTlH,EAAO7F,EAAE,GAAG6F,OACPtF,EAAI,EAAGA,EAAIP,EAAEN,OAAQa,IAC5BzB,EAAM+L,UAAUhF,EAAM7F,EAAEO,GAAGsF,eAEtBA,iCAGDzG,OACF8N,EAAS,eAERH,OAAO9I,SAAQ,SAAUjG,GAC5BkP,EAASA,EAAOlF,OAAOhK,EAAEkP,OAAO9N,OAG3B,IAAI0N,EAAWI,YC3E1B,IAAIzL,EAAI,CAAE9C,GAAG,EAAOC,GAAG,GAEvB,SAASuO,EAAY7H,EAAQ8H,EAAMC,MACpB,MAATD,MACS,MAATA,OAKAE,EAAU,EAAC,EAAO7L,EAAE9C,EAAG8C,EAAE7C,GAAGoJ,OAAOqF,GAEnCtF,EAAQ,IADczC,EAAOiI,KAAKC,MAAMlI,EAAQgI,IAEhDG,EAAOJ,EAAOhD,OAAO,UACzB5I,EAAI,CAAE9C,EAAG8O,EAAK,GAAI7O,EAAG6O,EAAK,IACnB1F,EATLtG,EAAI,CAAE9C,EAAG0O,EAAO,GAAIzO,EAAGyO,EAAO,KAY3B,SAASK,EAAapI,EAAQlG,WAE/BgO,EAEAO,EAHAC,ECfC,SAAwBxO,OAWzBmB,EACAsN,EACAC,EACAC,EAEAC,EACAlO,EAREmO,GAPN7O,EAAIA,EACD8O,QAAQ,KAAM,KACdA,QAAQ,KAAM,OACdA,QAAQ,QAAS,KACjBA,QAAQ,cAAe,SAGHA,QAAQ,iBAAkB,OAAO5C,MAAM,KACxD6C,EAAoBF,EAAavO,OAKnC0O,EAAO,GAGPC,EAAK,EACLC,EAAK,EACL3P,EAAI,EACJC,EAAI,EACJ2P,EAAK,EACLC,EAAK,EACLC,EAAM,EACNC,EAAM,EACNC,EAAa,OAKZpO,EAAI,EAAGA,EAAI4N,EAAmB5N,OAIjCwN,GADAD,GADAD,EAAcI,EAAa1N,IACV+C,UAAU,EAAG,IACrBsL,cAaTZ,GALAI,GAJAA,EAAOP,EACJK,QAAQJ,EAAI,IACZe,OACAvD,MAAM,MAEN5C,QAAO,SAAU1K,SACH,KAANA,KAER8D,IAAIuB,aACK3D,OAOA,MAARqO,MACFY,GAAc,KACH,MAAPb,GACFnP,GAAKyP,EAAK,GACVxP,GAAKwP,EAAK,KAEVzP,EAAIyP,EAAK,GACTxP,EAAIwP,EAAK,IAIXC,EAAK1P,EACL2P,EAAK1P,EACL+P,GAAchQ,EAAI,IAAMC,EAAI,IACxBoP,EAAO,MACJlO,EAAI,EAAGA,EAAIkO,EAAMlO,GAAK,EACd,MAAPgO,GACFnP,GAAKyP,EAAKtO,GACVlB,GAAKwP,EAAKtO,EAAI,KAEdnB,EAAIyP,EAAKtO,GACTlB,EAAIwP,EAAKtO,EAAI,IAEf6O,GAAc,CAAC,IAAKhQ,EAAGC,EAAG,IAAI6D,KAAK,UAGlC,GAAY,MAARsL,MAEJjO,EAAI,EAAGA,EAAIkO,EAAMlO,GAAK,EACd,MAAPgO,GACFnP,GAAKyP,EAAKtO,GACVlB,GAAKwP,EAAKtO,EAAI,KAEdnB,EAAIyP,EAAKtO,GACTlB,EAAIwP,EAAKtO,EAAI,IAEf6O,GAAc,CAAC,IAAKhQ,EAAGC,EAAG,IAAI6D,KAAK,UAEhC,GAAY,MAARsL,MACJjO,EAAI,EAAGA,EAAIkO,EAAMlO,IACT,MAAPgO,EACFnP,GAAKyP,EAAKtO,GAEVnB,EAAIyP,EAAKtO,GAEX6O,GAAc,CAAC,IAAKhQ,EAAGC,EAAG,IAAI6D,KAAK,UAEhC,GAAY,MAARsL,MACJjO,EAAI,EAAGA,EAAIkO,EAAMlO,IACT,MAAPgO,EACFlP,GAAKwP,EAAKtO,GAEVlB,EAAIwP,EAAKtO,GAEX6O,GAAc,CAAC,IAAKhQ,EAAGC,EAAG,IAAI6D,KAAK,UAEhC,GAAY,MAARsL,MAEJjO,EAAI,EAAGA,EAAIkO,EAAMlO,GAAK,EACd,MAAPgO,GACFS,EAAK5P,EAAIyP,EAAKtO,GACd0O,EAAK5P,EAAIwP,EAAKtO,EAAI,GAClBnB,GAAKyP,EAAKtO,EAAI,GACdlB,GAAKwP,EAAKtO,EAAI,KAEdyO,EAAKH,EAAKtO,GACV0O,EAAKJ,EAAKtO,EAAI,GACdnB,EAAIyP,EAAKtO,EAAI,GACblB,EAAIwP,EAAKtO,EAAI,IAEf6O,GAAc,CAAC,IAAKJ,EAAIC,EAAI7P,EAAGC,EAAG,IAAI6D,KAAK,UAExC,GAAY,MAARsL,MACJjO,EAAI,EAAGA,EAAIkO,EAAMlO,GAAK,EAEzByO,EAAK5P,GAAKA,EAAI4P,GACdC,EAAK5P,GAAKA,EAAI4P,GAEH,MAAPV,GACFnP,GAAKyP,EAAKtO,GACVlB,GAAKwP,EAAKtO,EAAI,KAEdnB,EAAIyP,EAAKtO,GACTlB,EAAIwP,EAAKtO,EAAI,IAEf6O,GAAc,CAAC,IAAKJ,EAAIC,EAAI7P,EAAGC,EAAG,IAAI6D,KAAK,UAExC,GAAY,MAARsL,MAEJjO,EAAI,EAAGA,EAAIkO,EAAMlO,GAAK,EACd,MAAPgO,GACFS,EAAK5P,EAAIyP,EAAKtO,GACd0O,EAAK5P,EAAIwP,EAAKtO,EAAI,GAClB2O,EAAM9P,EAAIyP,EAAKtO,EAAI,GACnB4O,EAAM9P,EAAIwP,EAAKtO,EAAI,GACnBnB,GAAKyP,EAAKtO,EAAI,GACdlB,GAAKwP,EAAKtO,EAAI,KAEdyO,EAAKH,EAAKtO,GACV0O,EAAKJ,EAAKtO,EAAI,GACd2O,EAAML,EAAKtO,EAAI,GACf4O,EAAMN,EAAKtO,EAAI,GACfnB,EAAIyP,EAAKtO,EAAI,GACblB,EAAIwP,EAAKtO,EAAI,IAEf6O,GAAc,CAAC,IAAKJ,EAAIC,EAAIC,EAAKC,EAAK/P,EAAGC,EAAG,IAAI6D,KAAK,UAElD,GAAY,MAARsL,MACJjO,EAAI,EAAGA,EAAIkO,EAAMlO,GAAK,EAEzByO,EAAK5P,GAAKA,EAAI8P,GACdD,EAAK5P,GAAKA,EAAI8P,GAEH,MAAPZ,GACFW,EAAM9P,EAAIyP,EAAKtO,GACf4O,EAAM9P,EAAIwP,EAAKtO,EAAI,GACnBnB,GAAKyP,EAAKtO,EAAI,GACdlB,GAAKwP,EAAKtO,EAAI,KAEd2O,EAAML,EAAKtO,GACX4O,EAAMN,EAAKtO,EAAI,GACfnB,EAAIyP,EAAKtO,EAAI,GACblB,EAAIwP,EAAKtO,EAAI,IAEf6O,GAAc,CAAC,IAAKJ,EAAIC,EAAIC,EAAKC,EAAK/P,EAAGC,EAAG,IAAI6D,KAAK,SAEtC,MAARsL,IACTY,GAAc,KAEdhQ,EAAI0P,EACJzP,EAAI0P,UAIDK,EAAWE,OD9KNC,CAAU1P,GAAGkM,MAAM,KAE3ByD,EAAU,IAAIC,OAAO,UAAW,IAGhCC,EAAW,GACXC,EAAO,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAG5N,EAAG,GAE3BmM,EAAMlO,QACX0N,EAAOQ,EAAMpN,OAAO,EAAG,GAAG,GACtBuO,EAAQO,KAAKlC,KAEfO,EAAUR,EAAW7H,EAAQ8H,EADpBQ,EAAMpN,OAAO,EAAG0O,EAAK9B,IAAOtL,IAAIuB,eAE5B4L,EAAS3N,KAAKqM,UAIxB,IAAIrI,EAAOwH,WAAWmC,GEjC/B,IAAM1R,EAAMC,KAAKD,IACXuI,EAAMtI,KAAKsI,IACXC,EAAMvI,KAAKuI,IACXtI,EAAMD,KAAKC,IACXC,EAAMF,KAAKE,IACXC,EAAOH,KAAKG,KACZE,EAAOL,KAAKK,KACZI,EAAKT,KAAKU,GAEVQ,EAAO,CAAEC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAMxB0Q,EAAqB,CAAC,IAAK,IAAK,KAEtC,SAASC,EAAQpL,EAAGqL,EAAGC,EAAGC,EAAGzQ,QACV,IAANA,IACTA,EAAI,QAEF0Q,EAAI9Q,EAAMwF,gBAAgBpF,EAAGkF,GAC7ByL,EAAK,EAAID,EACTT,EAAI,CACNxQ,EAAGiR,EAAIH,EAAE9Q,EAAIkR,EAAKF,EAAEhR,EACpBC,EAAGgR,EAAIH,EAAE7Q,EAAIiR,EAAKF,EAAE/Q,GAElB2D,EAAIzD,EAAMqF,SAASjF,EAAGkF,SAKnB,CAAE0L,EAJD,CACNnR,EAAG+Q,EAAE/Q,GAAK+Q,EAAE/Q,EAAIwQ,EAAExQ,GAAK4D,EACvB3D,EAAG8Q,EAAE9Q,GAAK8Q,EAAE9Q,EAAIuQ,EAAEvQ,GAAK2D,GAEVmN,EAAGA,EAAGP,EAAGA,OAGb7J,wBAUEyK,6CA+OA,SAAC7Q,OAERY,EACAC,EAFEH,EAAK,EAAIV,EAGXc,EAAI,EACJL,EAAIqQ,EAAK/O,QAAQ,GAEF,IAAf+O,EAAKvQ,QACPE,EAAI,CAACA,EAAE,GAAIA,EAAE,GAAIjB,GACjBoB,EAAIF,EACJG,EAAIb,GAEa,IAAf8Q,EAAKvQ,QACPK,EAAIF,EAAKA,EACTG,EAAIH,EAAKV,EAAI,EACbc,EAAId,EAAIA,OAGJW,EAAM,CACVlB,EAAGmB,EAAIH,EAAE,GAAGhB,EAAIoB,EAAIJ,EAAE,GAAGhB,EAAIqB,EAAIL,EAAE,GAAGhB,EACtCC,EAAGkB,EAAIH,EAAE,GAAGf,EAAImB,EAAIJ,EAAE,GAAGf,EAAIoB,EAAIL,EAAE,GAAGf,UAEpCoR,EAAKxQ,MACPK,EAAIhB,EAAIiB,EAAIH,EAAE,GAAGd,EAAIkB,EAAIJ,EAAE,GAAGd,EAAImB,EAAIL,EAAE,GAAGd,GAGtCgB,SAxQHuO,EAAO2B,GAAUA,EAAO9L,QAAU8L,EAAS,GAAG1F,MAAM4F,KAAKC,WACzDC,GAAW,KAEQ,WAAnBC,EAAOhC,EAAK,IAAiB,CAC/B+B,EAAW/B,EAAK1O,WAEV2Q,EAAU,GAEhBjC,EAAKnK,SAAQ,SAACH,GACZyL,EAAmBtL,SAAQ,SAAU7E,QACX,IAAb0E,EAAM1E,IACfiR,EAAQ/O,KAAKwC,EAAM1E,UAKzBgP,EAAOiC,MAGLC,GAAS,EACPzO,EAAMuM,EAAK1O,UAEbyQ,MACEA,EAAW,EAAG,IACS,IAArBD,UAAUxQ,aACN,IAAI6Q,MACR,wEAIJD,GAAS,WAGC,IAARzO,GAAqB,IAARA,GAAqB,IAARA,GAAqB,KAARA,GAChB,IAArBqO,UAAUxQ,aACN,IAAI6Q,MACR,4EAMF/Q,GACF8Q,IAAmB,IAARzO,GAAqB,KAARA,IACzBkO,GAAUA,EAAO,SAA6B,IAAhBA,EAAO,GAAGlR,OACtCW,IAAMA,UAELD,EAAS,GAEN2E,EAAM,EAAGsM,EAAOhR,EAAM,EAAI,EAAG0E,EAAMrC,EAAKqC,GAAOsM,EAAM,KACtD1M,EAAQ,CACZnF,EAAGyP,EAAKlK,GACRtF,EAAGwP,EAAKlK,EAAM,IAEZ1E,IACFsE,EAAMjF,EAAIuP,EAAKlK,EAAM,IAGvB3E,EAAO+B,KAAKwC,QAGTrE,MAAQF,EAAOG,OAAS,OACxBH,OAASA,MAEVqL,EAAO,CAAC,IAAK,KACbpL,GAAKoL,EAAKtJ,KAAK,UAEdsJ,KAAOA,OACP6F,OAAS7F,EAAKlL,gBAERqI,WACLtI,EAAQsI,EAAMtI,MACdF,EAASwI,EAAMxI,OACfO,EAAIhB,EAAMoJ,MAAM3I,EAAQ,CAAEiE,GAAIjE,EAAO,GAAIkE,GAAIlE,EAAOE,KAC/Cc,EAAI,EAAGA,EAAIT,EAAEJ,OAAQa,OACxBhD,EAAIuC,EAAES,GAAG3B,GAAK,iBAChBmJ,EAAM2I,SAAU,GAIpB3I,EAAM2I,SAAU,GACf1D,WAEE7B,IAAM,OACNC,IAAM,OAENuF,iDAGAzM,UACE8I,KAAKzN,OAAO2E,+BAGhBhF,UACI8N,KAAK1N,QAAQJ,mCAGbA,UACH8N,KAAKtM,OACA5B,EAAM2B,kBAAkBvB,EAAG8N,KAAKzN,OAAQyN,KAAKtM,OAAQsM,KAAKxN,KAG5DV,EAAMQ,QAAQJ,EAAG8N,KAAKzN,OAAQyN,KAAKxN,IAAKwN,KAAKtM,0CAM3CA,MACLA,EAAOhB,SAAWsN,KAAKzN,OAAOG,aAC1B,IAAI6Q,MAAM,yCAGb7P,OAASA,OACTkQ,KAAO,kCAONC,WACDC,SACLD,EAAQA,GAAS,IAEb7D,KAAK4D,KAAKlR,SAAWmR,SAChB7D,KAAK4D,UAGTA,KAAO,GAIZC,QACK,IAAI3R,EAAI,EAAGA,GAAK2R,EAAO3R,SACrB0R,KAAKtP,KAAK0L,KAAK1N,QAAQJ,EAAI2R,WAG3B7D,KAAK4D,gCAGV9M,EAAOiN,GACTA,EAAQA,GAAS,UAGb/Q,EAFEgR,EAAMhE,KAAKiE,SACXC,EAAO,GAEThS,EAAI,EAECqB,EAAI,EAAGA,EAAIyQ,EAAItR,OAAQa,IAC9BP,EAAIgR,EAAIzQ,GACJzB,EAAMyE,KAAKvD,EAAG8D,GAASiN,IACzBG,EAAK5P,KAAKtB,GACVd,GAAKqB,EAAIyQ,EAAItR,gBAIZwR,EAAKxR,QACFR,EAAKgS,EAAKxR,uCASXoE,OASHqN,EACAjS,EACAS,EACAP,EAVEyE,EAAMmJ,KAAKiE,SACX5R,EAAIwE,EAAInE,OAAS,EACjBkE,EAAU9E,EAAM8E,QAAQC,EAAKC,GAC/BE,EAAQJ,EAAQI,MACdD,EAAOH,EAAQG,KAQjB7D,GAAM6D,EAAO,GAAK1E,EAClBmR,EAAO,GAAMnR,MACjB2E,GAAS,EACImN,EAARjS,GAJK6E,EAAO,GAAK1E,EAIDH,EAAIgB,EAAKsQ,EAAMtR,GAAKsR,EACvC7Q,EAAIqN,KAAK1N,QAAQJ,IACjBE,EAAIN,EAAMyE,KAAKO,EAAOnE,IACdqE,IACNA,EAAQ5E,EACR+R,EAAKjS,UAGTS,EAAIqN,KAAK1N,QAAQ6R,IACfjS,EAAIiS,EACNxR,EAAEP,EAAI4E,EAECrE,0CAWH1B,EACAmT,EAJEzR,EAAIqN,KAAKzN,OACT8R,EAAK,CAAC1R,EAAE,IACRkK,EAAIlK,EAAED,OAIHa,EAAI,EAAGA,EAAIsJ,EAAGtJ,IACrBtC,EAAK0B,EAAEY,GACP6Q,EAAMzR,EAAEY,EAAI,GACZ8Q,EAAG9Q,GAAK,CACN5B,GAAIkL,EAAItJ,GAAKsJ,EAAI5L,EAAGU,EAAI4B,EAAIsJ,EAAIuH,EAAIzS,EACpCC,GAAIiL,EAAItJ,GAAKsJ,EAAI5L,EAAGW,EAAI2B,EAAIsJ,EAAIuH,EAAIxS,UAIxCyS,EAAGxH,GAAKlK,EAAEkK,EAAI,GAEP,IAAIvE,EAAO+L,2CAOXvS,EAAMY,OAAOsN,KAAKsE,WAAW/D,KAAKP,yCAwChC9N,UACFJ,EAAMyK,UAAUrK,EAAG8N,KAAKzN,OAAQyN,KAAKxN,kDAIrCV,EAAMsL,YAAY4C,KAAKzN,uCAGxBL,UACC8N,KAAKxN,IAAMwN,KAAKuE,UAAUrS,GAAK8N,KAAKwE,UAAUtS,qCAM5CA,OACHE,EAAI4N,KAAKsE,WAAWpS,GACpB4J,EAAIjL,EAAKuB,EAAET,EAAIS,EAAET,EAAIS,EAAER,EAAIQ,EAAER,SAE5B,CAAED,GAAIS,EAAER,EAAIkK,EAAGlK,EAAGQ,EAAET,EAAImK,qCAMtB5J,OAEHuS,EAAKzE,KAAKsE,WAAWpS,GACrBwS,EAAK1E,KAAKsE,WAAWpS,EAAI,KACzByS,EAAK9T,EAAK4T,EAAG9S,EAAI8S,EAAG9S,EAAI8S,EAAG7S,EAAI6S,EAAG7S,EAAI6S,EAAG5S,EAAI4S,EAAG5S,GAChDmK,EAAKnL,EAAK6T,EAAG/S,EAAI+S,EAAG/S,EAAI+S,EAAG9S,EAAI8S,EAAG9S,EAAI8S,EAAG7S,EAAI6S,EAAG7S,GACtD4S,EAAG9S,GAAKgT,EACRF,EAAG7S,GAAK+S,EACRF,EAAG5S,GAAK8S,EACRD,EAAG/S,GAAKqK,EACR0I,EAAG9S,GAAKoK,EACR0I,EAAG7S,GAAKmK,MAGFhJ,EAAI,CACRrB,EAAG+S,EAAG9S,EAAI6S,EAAG5S,EAAI6S,EAAG7S,EAAI4S,EAAG7S,EAC3BA,EAAG8S,EAAG7S,EAAI4S,EAAG9S,EAAI+S,EAAG/S,EAAI8S,EAAG5S,EAC3BA,EAAG6S,EAAG/S,EAAI8S,EAAG7S,EAAI8S,EAAG9S,EAAI6S,EAAG9S,GAEvB6C,EAAI3D,EAAKmC,EAAErB,EAAIqB,EAAErB,EAAIqB,EAAEpB,EAAIoB,EAAEpB,EAAIoB,EAAEnB,EAAImB,EAAEnB,GAE/CmB,EAAErB,GAAK6C,EACPxB,EAAEpB,GAAK4C,EACPxB,EAAEnB,GAAK2C,MAGDoQ,EAAI,CACR5R,EAAErB,EAAIqB,EAAErB,EACRqB,EAAErB,EAAIqB,EAAEpB,EAAIoB,EAAEnB,EACdmB,EAAErB,EAAIqB,EAAEnB,EAAImB,EAAEpB,EACdoB,EAAErB,EAAIqB,EAAEpB,EAAIoB,EAAEnB,EACdmB,EAAEpB,EAAIoB,EAAEpB,EACRoB,EAAEpB,EAAIoB,EAAEnB,EAAImB,EAAErB,EACdqB,EAAErB,EAAIqB,EAAEnB,EAAImB,EAAEpB,EACdoB,EAAEpB,EAAIoB,EAAEnB,EAAImB,EAAErB,EACdqB,EAAEnB,EAAImB,EAAEnB,SAIA,CACRF,EAAGiT,EAAE,GAAKH,EAAG9S,EAAIiT,EAAE,GAAKH,EAAG7S,EAAIgT,EAAE,GAAKH,EAAG5S,EACzCD,EAAGgT,EAAE,GAAKH,EAAG9S,EAAIiT,EAAE,GAAKH,EAAG7S,EAAIgT,EAAE,GAAKH,EAAG5S,EACzCA,EAAG+S,EAAE,GAAKH,EAAG9S,EAAIiT,EAAE,GAAKH,EAAG7S,EAAIgT,EAAE,GAAKH,EAAG5S,gCAMvCK,OAGA2S,EAFAlS,EAAIqN,KAAKzN,OACTuS,EAAK,GAEHhJ,EAAI,GACN5E,EAAM,EACN3D,EAAI,EACJlB,EAAI,MACRyJ,EAAE5E,KAASvE,EAAE,GACbmJ,EAAE5E,KAASvE,EAAE,GACbmJ,EAAE5E,KAASvE,EAAE,GACM,IAAfqN,KAAKvN,QACPqJ,EAAE5E,KAASvE,EAAE,IAIRA,EAAED,OAAS,GAAG,KACnBoS,EAAK,GACAvR,EAAI,EAAGlB,EAAIM,EAAED,OAAS,EAAGa,EAAIlB,EAAGkB,IACnCsR,EAAK/S,EAAMqD,KAAKjD,EAAGS,EAAEY,GAAIZ,EAAEY,EAAI,IAC/BuI,EAAE5E,KAAS2N,EACXC,EAAGxQ,KAAKuQ,GAEVlS,EAAImS,SAGChJ,gCAkBFM,EAAIlJ,MAEE,IAAPkJ,GAAclJ,SACT8M,KAAK1B,MAAMpL,GAAIuL,QAEb,IAAPvL,SACK8M,KAAK1B,MAAMlC,GAAIsC,UAIpB5C,EAAIkE,KAAK+E,KAAK3I,GACd4I,EAAS,CACXvG,KACiB,IAAfuB,KAAKvN,MACD,IAAI6F,EAAO,CAACwD,EAAE,GAAIA,EAAE,GAAIA,EAAE,KAC1B,IAAIxD,EAAO,CAACwD,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,KACtC4C,MACiB,IAAfsB,KAAKvN,MACD,IAAI6F,EAAO,CAACwD,EAAE,GAAIA,EAAE,GAAIA,EAAE,KAC1B,IAAIxD,EAAO,CAACwD,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,KACtCmJ,KAAMnJ,UAIRkJ,EAAOvG,KAAKN,IAAMrM,EAAMgD,IAAI,EAAG,EAAG,EAAGkL,KAAK7B,IAAK6B,KAAK5B,KACpD4G,EAAOvG,KAAKL,IAAMtM,EAAMgD,IAAIsH,EAAI,EAAG,EAAG4D,KAAK7B,IAAK6B,KAAK5B,KACrD4G,EAAOtG,MAAMP,IAAMrM,EAAMgD,IAAIsH,EAAI,EAAG,EAAG4D,KAAK7B,IAAK6B,KAAK5B,KACtD4G,EAAOtG,MAAMN,IAAMtM,EAAMgD,IAAI,EAAG,EAAG,EAAGkL,KAAK7B,IAAK6B,KAAK5B,KAGhDlL,GAKLA,EAAKpB,EAAMgD,IAAI5B,EAAIkJ,EAAI,EAAG,EAAG,GACZ4I,EAAOtG,MAAMJ,MAAMpL,GAEpBuL,MAPPuG,wCAcLrS,EACAuS,EAJEtH,EAAOoC,KAAKpC,KACZoH,EAAS,GACX1J,EAAQ,UAIZsC,EAAK3G,QACH,SAAU0G,GACRuH,EAAM,SAAUlU,UACPA,EAAE2M,IAEXhL,EAAIqN,KAAK/L,QAAQ,GAAGa,IAAIoQ,GACxBF,EAAOrH,GAAO7L,EAAMwK,OAAO3J,GACR,IAAfqN,KAAKvN,QACPE,EAAIqN,KAAK/L,QAAQ,GAAGa,IAAIoQ,GACxBF,EAAOrH,GAAOqH,EAAOrH,GAAK3C,OAAOlJ,EAAMwK,OAAO3J,KAEhDqS,EAAOrH,GAAOqH,EAAOrH,GAAKjC,QAAO,SAAUxJ,UAClCA,GAAK,GAAKA,GAAK,KAExBoJ,EAAQA,EAAMN,OAAOgK,EAAOrH,GAAKwH,KAAKrT,EAAM+N,cAC5CU,KAAKP,OAGT1E,EAAQA,EAAM6J,KAAKrT,EAAM+N,YAAYnE,QAAO,SAAU1K,EAAGkG,UAChDoE,EAAMlF,QAAQpF,KAAOkG,KAG9B8N,EAAO3E,OAAS/E,EAET0J,qCAIDI,EAAUpF,KAAKoF,UACfJ,EAAS,eACVpH,KAAK3G,QACR,SAAU7E,GACR4S,EAAO5S,GAAKN,EAAMgJ,UAAUkF,KAAM5N,EAAGgT,EAAQhT,KAC7CmO,KAAKP,OAGFgF,mCAGCjK,OACFsK,EAAQrF,KAAKnH,OACbyM,EAAQvK,EAAMlC,cAEb/G,EAAM0H,YAAY6L,EAAOC,kCAG1BpT,EAAGE,WACQ,IAANA,EAAmB,KACxBY,EAAIgN,KAAK/E,IAAI/I,GACbkF,EAAI4I,KAAKuF,OAAOrT,GAChBW,EAAM,CACRG,EAAGA,EACHoE,EAAGA,EACHzF,EAAGqB,EAAErB,EAAIyF,EAAEzF,EAAIS,EACfR,EAAGoB,EAAEpB,EAAIwF,EAAExF,EAAIQ,UAEb4N,KAAKxN,MACPK,EAAIhB,EAAImB,EAAEnB,EAAIuF,EAAEvF,EAAIO,GAEfS,KAGLmN,KAAK0D,QAAS,KACZ8B,EAAKxF,KAAKuF,OAAO,SAWd,CAAC,IAAIjN,EAVC0H,KAAKzN,OAAOuC,KAAI,SAAUnC,OACjCE,EAAM,CACRlB,EAAGgB,EAAEhB,EAAIO,EAAIsT,EAAG7T,EAChBC,EAAGe,EAAEf,EAAIM,EAAIsT,EAAG5T,UAEde,EAAEd,GAAKuF,EAAEvF,IACXgB,EAAIhB,EAAIc,EAAEd,EAAIK,EAAIsT,EAAG3T,GAEhBgB,cAKKmN,KAAKzE,SAENzG,KAAI,SAAUS,UACvBA,EAAEmO,QACGnO,EAAE2K,OAAOhO,GAAG,GAEdqD,EAAEkQ,MAAMvT,0CAQE,IAAf8N,KAAKvN,MAAa,KAChBiH,EAAK5H,EAAM8D,MAAMoK,KAAKzN,OAAO,GAAIyN,KAAKzN,OAAO,GAAIyN,KAAKzN,OAAO,IAC7DwH,EAAKjI,EAAM8D,MAAMoK,KAAKzN,OAAO,GAAIyN,KAAKzN,OAAO,GAAIyN,KAAKzN,OAAO,OAC5DmH,EAAK,GAAKK,EAAK,GAAOL,EAAK,GAAKK,EAAK,EAAI,OAAO,MAGjD2L,EAAK1F,KAAKuF,OAAO,GACjBI,EAAK3F,KAAKuF,OAAO,GAEnBhQ,EAAImQ,EAAG/T,EAAIgU,EAAGhU,EAAI+T,EAAG9T,EAAI+T,EAAG/T,SAC5BoO,KAAKxN,MACP+C,GAAKmQ,EAAG7T,EAAI8T,EAAG9T,GAGHtB,EAAII,EAAK4E,IAERtE,EAAK,uCAIhBsC,EAIAoN,EAHAvE,EAAK,EACLlJ,EAAK,EAGL0S,EAAQ,GACRC,EAAQ,GAERT,EAAUpF,KAAKoF,UAAU/E,YACD,IAAxB+E,EAAQhP,QAAQ,KAClBgP,EAAU,CAAC,GAAGpK,OAAOoK,KAEK,IAAxBA,EAAQhP,QAAQ,IAClBgP,EAAQ9Q,KAAK,GAGV8H,EAAKgJ,EAAQ,GAAI7R,EAAI,EAAGA,EAAI6R,EAAQ1S,OAAQa,IAC/CL,EAAKkS,EAAQ7R,IACboN,EAAUX,KAAK1B,MAAMlC,EAAIlJ,IACjBiL,IAAM/B,EACduE,EAAQvC,IAAMlL,EACd0S,EAAMtR,KAAKqM,GACXvE,EAAKlJ,SAIP0S,EAAM3O,SAAQ,SAAUT,OACtB4F,EAAK,EACLlJ,EAAK,EACEA,GAAM,OACNA,EAAKkJ,EA3BH,IA2BclJ,GAAM,KAAUA,GA3B9B,SA4BLyN,EAAUnK,EAAG8H,MAAMlC,EAAIlJ,IACV4S,SAAU,IAEjBvV,EAAI6L,GADRlJ,GA9BG,MAAA,UAiCM,IAETyN,EAAUnK,EAAG8H,MAAMlC,EAAIlJ,IACfiL,IAAMrM,EAAMgD,IAAIsH,EAAI,EAAG,EAAG5F,EAAG2H,IAAK3H,EAAG4H,KAC7CuC,EAAQvC,IAAMtM,EAAMgD,IAAI5B,EAAI,EAAG,EAAGsD,EAAG2H,IAAK3H,EAAG4H,KAC7CyH,EAAMvR,KAAKqM,GACXvE,EAAKlJ,QAKPkJ,EAAK,KACPuE,EAAUnK,EAAG8H,MAAMlC,EAAI,IACf+B,IAAMrM,EAAMgD,IAAIsH,EAAI,EAAG,EAAG5F,EAAG2H,IAAK3H,EAAG4H,KAC7CuC,EAAQvC,IAAM5H,EAAG4H,IACjByH,EAAMvR,KAAKqM,OAGRkF,gCAGFzT,OACDK,EAAQuN,KAAKvN,MACbsT,GAAa,KACA,mBAAN3T,IACT2T,EAAa3T,GAEX2T,GAAwB,IAAVtT,SACTuN,KAAKgG,QAAQP,MAAMM,OAIxBE,EAAYjG,KAAKiG,UACjBxB,EAAKsB,EAAaA,EAAW,GAAK3T,EAClCsS,EAAKqB,EAAaA,EAAW,GAAK3T,EAClCpB,EAAI,CAACgP,KAAKE,OAAO,EAAG,IAAKF,KAAKE,OAAO,EAAG,KACxCrK,EAAI/D,EAAMmG,KAAKjH,EAAE,GAAIA,EAAE,GAAGgC,EAAGhC,EAAE,GAAIA,EAAE,GAAGgC,OACvC6C,QACG,IAAI0N,MAAM,uDAGdhR,EAASyN,KAAKzN,OACd8R,EAAK,UAGR,EAAG,GAAGpN,SACL,SAAU/E,OACJS,EAAK0R,EAAGnS,EAAIO,GAASX,EAAM4D,KAAKnD,EAAOL,EAAIO,IAC/CE,EAAEhB,IAAMO,EAAIwS,EAAKD,GAAMzT,EAAEkB,GAAGkF,EAAEzF,EAC9BgB,EAAEf,IAAMM,EAAIwS,EAAKD,GAAMzT,EAAEkB,GAAGkF,EAAExF,KAI7BmU,IAiBJ,EAAG,GAAG9O,QACL,SAAU/E,MACW,IAAf8N,KAAKvN,QAAiBP,OACtBS,EAAIJ,EAAOL,EAAI,GACfgU,EAAK,CACPvU,EAAGgB,EAAEhB,EAAIkE,EAAElE,EACXC,EAAGe,EAAEf,EAAIiE,EAAEjE,GAETuU,EAAKJ,EAAaA,GAAY7T,EAAI,GAAKO,GAASL,EAChD2T,IAAeE,IAAWE,GAAMA,OAChC3R,EAAI3D,EAAKqV,EAAGvU,EAAIuU,EAAGvU,EAAIuU,EAAGtU,EAAIsU,EAAGtU,GACrCsU,EAAGvU,GAAK6C,EACR0R,EAAGtU,GAAK4C,EACR6P,EAAGnS,EAAI,GAAK,CACVP,EAAGgB,EAAEhB,EAAIwU,EAAKD,EAAGvU,EACjBC,EAAGe,EAAEf,EAAIuU,EAAKD,EAAGtU,KAEnB2O,KAAKP,OAGF,IAAI1H,EAAO+L,MAlCf,EAAG,GAAGpN,QACL,SAAU/E,MACW,IAAf8N,KAAKvN,QAAiBP,OACtBS,EAAI0R,EAAGnS,EAAIO,GACXL,EAAI4N,KAAKsE,WAAWpS,GACpBuE,EAAK,CAAE9E,EAAGgB,EAAEhB,EAAIS,EAAET,EAAGC,EAAGe,EAAEf,EAAIQ,EAAER,GACpCyS,EAAGnS,EAAI,GAAKJ,EAAMmG,KAAKtF,EAAG8D,EAAIZ,EAAGtD,EAAOL,EAAI,MAC5CqO,KAAKP,OAEF,IAAI1H,EAAO+L,oCA4BbvH,EAAIC,EAAIqJ,EAAIC,GACnBtJ,OAAmB,IAAPA,EAAqBD,EAAKC,MAKlCpK,EAJA2T,EAAUtG,KAAKzE,SACf1G,EAAMyR,EAAQ5T,OACd6T,EAAU,GACVC,EAAU,GAEVxF,EAAO,EACPyF,EAAOzG,KAAKtN,SAEZgU,OAA0B,IAAPN,QAAoC,IAAPC,WAE3CM,EAAwBpR,EAAGqK,EAAG6G,EAAMzF,EAAM4F,UAC1C,SAAU5V,OACX4C,EAAKoN,EAAOyF,EACZ5S,GAAMmN,EAAO4F,GAAQH,EACrBrU,EAAIwN,EAAIrK,SACLzD,EAAMgD,IAAI9D,EAAG,EAAG,EAAGuE,EAAI3B,EAAKxB,EAAGmD,EAAI1B,EAAKzB,IAKnDkU,EAAQrP,SAAQ,SAAU0J,GACxBiG,EAAOjG,EAAQjO,SACXgU,GACFH,EAAQjS,KACNqM,EAAQ8E,MAAMkB,EAAuB7J,EAAIsJ,EAAIK,EAAMzF,EAAM4F,KAE3DJ,EAAQlS,KACNqM,EAAQ8E,MAAMkB,GAAwB5J,GAAKsJ,EAAII,EAAMzF,EAAM4F,OAG7DL,EAAQjS,KAAKqM,EAAQ8E,MAAM3I,IAC3B0J,EAAQlS,KAAKqM,EAAQ8E,OAAO1I,KAE9BiE,GAAQ4F,KAIVJ,EAAUA,EACP1R,KAAI,SAAUS,UACb5C,EAAI4C,EAAEhD,QACA,GACJgD,EAAEhD,OAAS,CAACI,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAEhC4C,EAAEhD,OAAS,CAACI,EAAE,GAAIA,EAAE,GAAIA,EAAE,IAErB4C,KAERsR,cAGCC,EAAKP,EAAQ,GAAGhU,OAAO,GACvBwU,EAAKR,EAAQ1R,EAAM,GAAGtC,OAAOgU,EAAQ1R,EAAM,GAAGtC,OAAOG,OAAS,GAC9DsU,EAAKR,EAAQ3R,EAAM,GAAGtC,OAAOiU,EAAQ3R,EAAM,GAAGtC,OAAOG,OAAS,GAC9DuU,EAAKT,EAAQ,GAAGjU,OAAO,GACvB2U,EAAKpV,EAAMuG,SAAS2O,EAAIF,GACxBK,EAAKrV,EAAMuG,SAAS0O,EAAIE,GACxBhF,EAAW,CAACiF,GACblM,OAAOuL,GACPvL,OAAO,CAACmM,IACRnM,OAAOwL,GACNI,EAAO3E,EAASvP,cAEb,IAAIoN,EAAWmC,yCAMTnF,EAAIC,EAAIxD,GACrBwD,EAAKA,GAAMD,UACPsK,EAAUpH,KAAKoH,QAAQtK,EAAIC,GAAIgD,OAC/BsH,EAAS,GACJ9T,EAAI,EAAGsB,EAAMuS,EAAQ1U,OAAQa,EAAIsB,EAAM,EAAGtB,IAAK,KAClDqH,EAAQ9I,EAAMyI,UAChB6M,EAAQ7T,GACR6T,EAAQvS,EAAMtB,GACdgG,GAEFqB,EAAMjB,SAASM,QAAU1G,EAAI,EAC7BqH,EAAMd,OAAOG,QAAU1G,EAAIsB,EAAM,EAAI,EACrCwS,EAAO/S,KAAKsG,UAEPyM,qCAQGtM,EAAOxB,UACZwB,EACDA,EAAMvE,IAAMuE,EAAMtE,GACbuJ,KAAKsH,eAAevM,IAEzBA,aAAiBzC,IACnByC,EAAQA,EAAMQ,UAGTyE,KAAKuH,gBACVvH,KAAKzE,SACLR,EACAxB,IAXiByG,KAAKwH,eAAejO,0CAezB4B,OACV1C,EAAKK,EAAIqC,EAAK3E,GAAG7E,EAAGwJ,EAAK1E,GAAG9E,GAC5B+G,EAAKI,EAAIqC,EAAK3E,GAAG5E,EAAGuJ,EAAK1E,GAAG7E,GAC5B+G,EAAKI,EAAIoC,EAAK3E,GAAG7E,EAAGwJ,EAAK1E,GAAG9E,GAC5BiH,EAAKG,EAAIoC,EAAK3E,GAAG5E,EAAGuJ,EAAK1E,GAAG7E,GAC5BiJ,EAAOmF,YACJlO,EAAMwJ,MAAM0E,KAAKzN,OAAQ4I,GAAMO,QAAO,SAAUxJ,OACjDS,EAAIkI,EAAKI,IAAI/I,UACVJ,EAAMyC,QAAQ5B,EAAEhB,EAAG8G,EAAIE,IAAO7G,EAAMyC,QAAQ5B,EAAEf,EAAG8G,EAAIE,6CAIhDW,OAKVhG,EAGAyR,EACAvG,EACAC,EATA4H,EAAUtG,KAAKzE,SAKf1G,EAAMyR,EAAQ5T,OAAS,EACvBkM,EAAU,OAITrL,EAAI,EAAGA,EAAIsB,EAAKtB,IACnBkL,EAAO6H,EAAQjJ,MAAM9J,EAAGA,EAAI,GAC5BmL,EAAQ4H,EAAQjJ,MAAM9J,EAAI,GAC1ByR,EAAShF,KAAKuH,gBAAgB9I,EAAMC,EAAOnF,GAC3CqF,EAAUA,EAAQ5D,OAAOgK,UAEpBpG,0CAGQvE,EAAIC,EAAIf,OACnBiF,EAAQ,GAEZnE,EAAGpD,SAAQ,SAAU5E,GACnBiI,EAAGrD,SAAQ,SAAUtD,GACftB,EAAEoV,SAAS9T,IACb6K,EAAMlK,KAAK,CAAEmK,KAAMpM,EAAGqM,MAAO/K,cAK/B8F,EAAgB,UACpB+E,EAAMvH,SAAQ,SAAU0H,OAClBqG,EAASlT,EAAMiM,cACjBY,EAAKF,KACLE,EAAKD,MACLnF,GAEEyL,EAAOtS,OAAS,IAClB+G,EAAgBA,EAAcuB,OAAOgK,OAGlCvL,+BAGHiO,GACJA,EAAiBA,GAAkB,UAE5B1H,KAAK2H,SAASD,EADP,mCAOR7L,EAAI+L,EAAKrS,EAAGqK,OACd9D,GAAK8D,EAAIrK,GAAK,EACd8E,EAAK2F,KAAK/E,IAAI1F,EAAIuG,GAClBxB,EAAK0F,KAAK/E,IAAI2E,EAAI9D,GAClB+L,EAAM/V,EAAMyE,KAAKsF,EAAI+L,GACrB9K,EAAKhL,EAAMyE,KAAKsF,EAAIxB,GACpB0C,EAAKjL,EAAMyE,KAAKsF,EAAIvB,UACjB/J,EAAIuM,EAAK+K,GAAOtX,EAAIwM,EAAK8K,oCAGxBH,EAAgBI,OAIpBC,EAFAC,EAAM,EACNC,EAAM,IAGP,CACDF,EAAS,EAGTE,EAAM,MAIFC,EACAC,EACAxI,EACAyI,EAKAC,EATAT,EAAM5H,KAAK/E,IAAI+M,GAOfM,GAAY,EACZC,GAAY,EAIZC,EAAMP,EACNQ,EAAS,IAGV,IACDF,EAAYD,EACZF,EAAWzI,EACX6I,GAAOR,EAAMC,GAAO,EAEpBC,EAAMlI,KAAK/E,IAAIuN,GACfL,EAAMnI,KAAK/E,IAAIgN,IAEftI,EAAM7N,EAAM+M,WAAW+I,EAAKM,EAAKC,IAG7BO,SAAW,CACbhO,MAAOsN,EACPrN,IAAKsN,GAIPK,EADYtI,KAAK2I,OAAOhJ,EAAKiI,EAAKI,EAAKC,IAClBP,GAErBW,EAAOE,IAAcD,KACVG,EAASR,GAGhBK,EAAW,IAETL,GAAO,EAAG,IAEZtI,EAAI+I,SAAS/N,IAAM8N,EAAS,EAC5BL,EAAWzI,EAGPsI,EAAM,EAAG,KACP7V,EAAI,CACNT,EAAGgO,EAAIhO,EAAIgO,EAAIhM,EAAIlD,EAAIkP,EAAIC,GAC3BhO,EAAG+N,EAAI/N,EAAI+N,EAAIhM,EAAIjD,EAAIiP,EAAIC,IAE7BD,EAAIC,GAAK9N,EAAM8D,MAAM,CAAEjE,EAAGgO,EAAIhO,EAAGC,EAAG+N,EAAI/N,GAAKQ,EAAG4N,KAAK/E,IAAI,UAK7DgN,IAAaA,EAAMD,GAAO,OAG1BC,EAAMO,SAEAH,GAAQN,IAAW,QAEzBA,GAAU,UAMdK,EAAWA,GAAYzI,EACvBmI,EAAQxT,KAAK8T,GACbJ,EAAMS,QACCR,EAAM,UAGRH,4CAIAhW,2CAIAkO,KAAKC,qDAOLnO,EAAM0D,eAAewK,KAAKzN,2CAQ7ByN,KAAKxN,WACA,UAGLG,EAAIqN,KAAKzN,OAGTgD,EAAI,CAAC,IAFD5C,EAAE,GAAGhB,EACLgB,EAAE,GAAGf,EACsB,IAAfoO,KAAKvN,MAAc,IAAM,KAEpCc,EAAI,EAAGkN,EAAO9N,EAAED,OAAQa,EAAIkN,EAAMlN,IACzCgC,EAAEjB,KAAK3B,EAAEY,GAAG5B,GACZ4D,EAAEjB,KAAK3B,EAAEY,GAAG3B,UAGP2D,EAAEE,KAAK,0CAORmT,EAAQ5I,KAAK6I,cAEfD,IAAU5I,KAAK8I,cACZA,OAASF,OACTjF,uDAQA3D,KAAKzN,OACTuC,KAAI,SAACiU,EAAcxV,SAAM,GAAKA,EAAIwV,EAAapX,EAAIoX,EAAanX,GAAKmX,EAAalX,GAAK,MACvF4D,KAAK,mCAUFuT,QAEDpF,KAAO,QACP3P,QAAUnC,EAAMkC,OAAOgM,KAAKzN,OAAQyN,KAAKxN,UACzCyW,kEAIC1W,EAASyN,KAAKzN,OACdqD,EAAQ9D,EAAM8D,MAAMrD,EAAO,GAAIA,EAAOyN,KAAKvN,OAAQF,EAAO,SAE3D0T,UAAYrQ,EAAQ,yCAMNxD,UACZ8W,EAAa5Q,EAAQlG,+CAGFoE,EAAIC,EAAIyB,EAAIhG,eACrB,IAANA,IACTA,EAAI,IAGI,IAANA,EACK,IAAIoG,EAAO7B,EAAIA,EAAIyB,GAElB,IAANhG,EACK,IAAIoG,EAAO9B,EAAIC,EAAIA,GAIrB,IAAI6B,EAAO9B,EADRgM,EAAO,EAAGhM,EAAIC,EAAIyB,EAAIhG,GACN4Q,EAAG5K,2CAGPuK,EAAGC,EAAGC,EAAGzQ,EAAG4K,QACjB,IAAN5K,IACTA,EAAI,QAEFiX,EAAM3G,EAAO,EAAGC,EAAGC,EAAGC,EAAGzQ,QACX,IAAP4K,IACTA,EAAKhL,EAAMyE,KAAKmM,EAAGyG,EAAIhH,QAErBpF,EAAKD,GAAM,EAAI5K,GAAKA,EAEpBkX,EAAQtX,EAAMyE,KAAKkM,EAAGE,GACtB0G,GAAM1G,EAAEhR,EAAI8Q,EAAE9Q,GAAKyX,EACnBE,GAAM3G,EAAE/Q,EAAI6Q,EAAE7Q,GAAKwX,EACnBG,EAAMzM,EAAKuM,EACXG,EAAM1M,EAAKwM,EACXG,EAAM1M,EAAKsM,EACXK,EAAM3M,EAAKuM,EAEXK,EAAUjH,EAAE/Q,EAAI4X,EAAhBI,EAAwBjH,EAAE9Q,EAAI4X,EAC9BI,EAAUlH,EAAE/Q,EAAI8X,EAAhBG,EAAwBlH,EAAE9Q,EAAI8X,EAC9B5G,EAAIqG,EAAIrG,EACR1N,EAAU0N,EAAEnR,GAAKgY,EAAO7G,EAAEnR,IAAM,EAAIO,GAApCkD,EAA2C0N,EAAElR,GAAK+X,EAAO7G,EAAElR,IAAM,EAAIM,GACrEmD,EAAUyN,EAAEnR,GAAKiY,EAAO9G,EAAEnR,GAAKO,EAA/BmD,EAAqCyN,EAAElR,GAAKgY,EAAO9G,EAAElR,GAAKM,SAOvD,IAAIoG,EAAOmK,EANR,CAAE9Q,EAAG8Q,EAAE9Q,GAAKyD,EAAOqN,EAAE9Q,GAAKO,EAAGN,EAAG6Q,EAAE7Q,GAAKwD,EAAOqN,EAAE7Q,GAAKM,GACrD,CACRP,EAAGgR,EAAEhR,GAAK0D,EAAOsN,EAAEhR,IAAM,EAAIO,GAC7BN,EAAG+Q,EAAE/Q,GAAKyD,EAAOsN,EAAE/Q,IAAM,EAAIM,IAGAyQ,6CAIxB7Q,oBAtkCEwG,eAykCSwH"}