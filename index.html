<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Bezier.js, for doing bezier curve things</title>
    <style>
      body { padding: 0 1em; }
      dl { width: calc(100% - 3em); margin-left: 1em; }
      dt { font-weight: bold; }
      dd { position: relative; top: -1em; left: 5.5em; margin-right: 5em; margin-bottom: -1em; }
      canvas { position: relative; border: 1px solid rgba(0,0,0,0.2); }
      .caption { display: block; font-style: italic; font-size:70%; font-family: Arial;}
    </style>
  </head>
  <body>
    <h1>Bezier.js, for doing bezier curve things</h1>

    <p>A library for performing Bezier curve computation and, if you add in your own drawing code (like the HTML canvas), drawing curves in a useful manner. The following animated, interactive diagram actually shows off everything currently supported by the library. Have a look at <a href="https://github.com/Pomax/bezierjs/blob/gh-pages/beziertest.js" target="_blank">the drawing code</a> to see how this is drawn, or read the <a href="https://github.com/Pomax/bezierjs/blob/gh-pages/bezier.js#L225">bezier.js source</a> to see how everything works. It's... pretty straight-forward code, really. <strong>Try playing with the curve</strong>: as this is an interactive graphic, you can drag around the start, control, and end points to manipulate the curve.</p>

    <div style="text-align:center">
      <canvas width="900" height="280"></canvas>
      <span class="caption">An interactive Bezier curve animation. The curve has an arc length of <span id="arclength">0</span> pixels</span>
    </div>

    <p>The diagram shows:
      <b>(1)</b> a curve that's being rendered split at a "t" value that moves between 0 and 1, with
      <b>(2)</b> the resulting subcurves colours differently so that it's obvious they're different segments.
      <b>(3)</b> The travelling "t" point is also showing
      <b>(4)</b> its (scaled to have a sensible length) tangent vector, and
      <b>(5)</b> its (scaled) normal vector.
      <b>(6)</b> In pink/purple we see all the inflection points that this curve has, and
      <b>(7)</b> The curve's control points are shown in dark grey,
      <b>(8)</b> the bounding box for this curve is shown fading in and out depending on the "t" position, with
      <b>(9)</b> the bounding boxes for each of the "simple" segments fading in counter-point.
      <b>(10)</b> in the mioddle, in grey, we see the curve's "offset curve", which is actually a poly-bezier consisting of the curve split up into "simple" segments (defined as sections with an angle of no more than PI/6 between the start and end normals), each of which has been scaled to lie (very close to) a fixed distance "d" along the curve's normal field away from the curve. The original curve is superimposed on the offset shape.
      <b>(11)</b> On the right we see the path converted to a filled outline shape, with
      <b>(12)</b> the intersection of a line computed against all the outline curve's Bezier segments.
      <b>(13)</b> If, by manipulating the curve, you get outline intersections, these are show on the right, with
      <b>(14)</b> all subsections involved in the intersection(s) highlighed. Note that only the endcaps are "real", and no intersections will be seen when a subsection's edge curves cross a subsection separator.
    </p>

    <h2>The API for this library:</h2>

    <dl>
      <dt>new Bezier(...)</dt>
      <dd>constructor taking either [c,c,c,c] where c is an {x:..., y:..., z:...} coordinate (z optional), or an array of size 8 or 12 ordered x,y,z,x,y,z,x,y,z,x,y,z where z is optional.</dt>
    </dl>

    <dl>
      <dt>.length()</dt>
      <dd>yields the curve's arc length (this is an expensive operation and as such is not automatically recomputed when you change the curve's coordinates, but is a function you have to call yourself).</dd>

      <dt>.getLUT(steps)</dt>
      <dd>yields array/steps of {x:..., y:..., z:...} coordinates.</dd>

      <dt>.get(t)</dt>
      <dd>alias for compute(t).</dd>

      <dt>.compute(t)</dt>
      <dd>yields the curve coordinate at 't'.</dd>

      <dt>.derivative(t)</dt>
      <dd>yields the curve derivative at 't' as vector.</dd>

      <dt>.normal(t)</dt>
      <dd>yields the normal vector for the curve at 't'.</dd>

      <dt>.split(t)</dt>
      <dd>split the curve at 't' and return both segments as new curves.</dd>

      <dt>.split(t1,t2)</dt>
      <dd>split the curve between 't1' and 't2' and return the segment as new curve.</dd>

      <dt>.inflections()</dt>
      <dd>yields all known inflection points on this curve as {x:[...], y:[...], z:[...], values:[...]}, 'values' acting as aggregate for x/y/z.</dd>

      <dt>.offset(t, d)</dt>
      <dd>yields a coordinate that is a point on the curve at 't', offset by distance 'd' alongits normal.</dd>

      <dt>.reduce()</dt>
      <dd>yields an array of 'simple' curve segments that model the curve as poly-simple-beziers. Simple curves have both control points on the same side of the curve, and have an angle between the start/end normals of at most π/6 (60 degrees). A reduced curve is first split on all its inflections, then the resulting segments are further split into
      simple segments if necessary.</dd>

      <dt>.scale(d)</dt>
      <dd>yields the curve scaled approximately along its normals by distance 'd'.</dd>

      <dt>.outline(d)</dt>
      <dd>yields the outline coordinates for the curve offset by 'd' pixels on either side, encoded as as an object of form {"+":[p,...], "-":[p,...]}, where each point 'p' is of the form {p: {x:..., y:..., z:...}, c: true/false}. z is optional, and c:true means on-curve point, with c:false means off-curve point.</dd>

      <dt>.outline(d1,d2)</dt>
      <dd>yields the outline coordinates for the curve offset by d1 on its normal, and d2 on its opposite side.</dd>

      <dt>.outlineshapes(...)</dt>
      <dd>same signature as ".outline" - yields an array of shapes that, taken in sequence, model the original curve's filled outline. Each shape maps to the outline for individual simple curves that are generated by the ".reduce" function. Each shape is of the form { startcap: curve, forward: curve, endcap: curve, back: curve, bbox: bounding box}.</dd>

      <dt>.intersects()</dt>
      <dd>yields the array of self-intersection 't' values, as "t1/t2" string, where t1 and t2 are floating point numbers rounded to six decimal places.</dd>

      <dt>.intersects(line)</dt>
      <dd>yields the array of intersection 't' values between this curve and a target line, encoded as "t1/t2" string, where t1 and t2 are floating point numbers rounded to six decimal places. The line must be of the form {p1:{x:.., y:...}, p2:{x:..., y:...}}.</dd>

      <dt>.intersects(curve)</dt>
      <dd>yields the array of intersection 't' values between this curve and a target curve, encoded as "t1/t2" string, where t1 and t2 are floating point numbers rounded to six decimal places, and each t1 is the 't' value on this curve, and each t2 is the 't' value on the target curve.</dd>
    </dl>

    <p>Made by <a href="https://twitter.com/TheRealPomax">Pomax</a>. Based on the work done for <a href="http://pomax.github.io/bezierinfo">A Primer on Bézier Curves</a>. Naturally, the code's open source over on <a href="http://github.com/Pomax/bezierjs">github</a>. Still to do: intersection resolution for outlines with overlapping extrusions.</p>

    <script src="bezierutils.js"></script>
    <script src="bezier.js"></script>
    <script src="draw.js"></script>
    <script src="beziertest.js"></script>
    <script src="interaction.js"></script>
  </body>
</html>