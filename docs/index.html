<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Bezier.js, for doing Bezier curve things</title>
    <link rel="stylesheet" href="style.css">
    <script src="js/loader.js" async defer></script>                 
    <script type="module">
      import { Bezier } from  "./js/bezier.js";
      window.Bezier = Bezier;
    </script>
  </head>
  <body>
    <header>
      <h1>Bezier.js, for doing Bezier curve things</h1>
    </header>

    <main>
      <p>A library for performing Bezier curve computation and, if you add in your own drawing code (like the HTML canvas), drawing curves in a useful manner.</p>

      <p>This library works both client side (i.e. in the browser) and server side (e.g. as a <a href="https://nodejs.org">node.js</a> module).</p>

      <p>Install using npm or yarn, download the library <a href="./bezier.js">here</a>, or head over to <a href="https://github.com/Pomax/bezierjs">Github</a> for the project page.</p>

      <h2>This is an interactive API</h2>

      <p>The rest of this page explains the Bezier.js API, with interactive graphics to illustrate what a function does. Because what's the point of a library for manipulating Bezier curves if you can't manipulate them? You can click-drag all the points to see how the curves behave under the different functions that can act on them.</p>

      <p><strong>Basically: the graphics on this page want you to play with them. They're not static images.</strong></p>


      <section id="constructor">
        <a href="#constructor"><h1>new Bezier(...)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
            }
          </script></figure>
        </figures>

        <p>Quadratic and cubic 2D/3D Bezier curve constructor.</p>

        <p>For quadratic curves, the contructor can take either 6 or 9 numerical arguments
          (for 2d and 3d curves respectively) or 3 <code>{x:(num),y:(num),z:(num)}</code> coordinate objects.
          The <code>z</code> property for coordinates is optional, and controls whether the resulting curve
          is 2d or 3d.</p>

        <p>For cubic curves, the contructor can take either 8 or 12 numerical arguments
          (for 2d and 3d curves respectively) or 4 <code>{x:(num),y:(num),z:(num)}</code> coordinate objects.
          The <code>z</code> property for coordinates is optional, and controls whether the resulting curve
          is 2d or 3d.</p>
      </section>

      <section id="fromPoints">
        <a href="#fromPoints"><h1>Bezier.quadraticFromPoints(p1,p2,p3,t) / Bezier.cubicFromPoints(p1,p2,p3,t,d1)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            false;
            var B = {x: 100, y: 50};
            var tvalues = [0.2, 0.3, 0.4, 0.5];
            var curves = tvalues.map(t => Bezier.quadraticFromPoints({x:150, y: 40}, B, {x:35, y:160}, t));
            var draw = function() {
              var offset = {x:45,y:30};
              curves.forEach((b,i) => {
                this.drawSkeleton(b, offset, true);
                this.setColor("rgba(0,0,0,0.2)");
                this.drawCircle(b.points[1], 3, offset);
                this.drawText("t=" + tvalues[i], {
                  x: b.points[1].x + offset.x - 15,
                  y: b.points[1].y + offset.y - 10,
                });
                this.setRandomColor();
                this.drawCurve(b, offset);
              });
              this.setColor("black");
              this.drawCircle(curves[0].points[0], 3, offset);
              this.drawCircle(curves[0].points[2], 3, offset);
              this.drawCircle(B, 3, offset);
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            false;
            var p1 = {x:110, y: 50},
                B  = {x: 50, y: 80},
                p3 = {x:135, y: 100};
            var tvalues = [0.2, 0.3, 0.4, 0.5];
            var curves = tvalues.map(t => Bezier.cubicFromPoints(p1, B, p3, t));
            var draw = function() {
              var offset = {x:0,y:0};
              curves.forEach((b,i) => {
                this.setRandomColor();
                this.drawCurve(b, offset);
              });
              this.setColor("black");
              this.drawCircle(curves[0].points[0], 3, offset);
              this.drawCircle(curves[0].points[3], 3, offset);
              this.drawCircle(B, 3, offset);
            }
          </script></figure>
        </figures>

        <p>Create a curve through three points.</p>

        <p>The points p1 through p3 are required, all additional arguments are optional. In both cases <code>t</code> defaults
        to <code>0.5</code> when omitted.</p>

        <p>The cubic value <code>d1</code> indicates the strut length for building a cubic curve, with the full strut being
        length <code>d1 * (1-t)/t</code>. If omitted, a length based on <code>B--C</code> is used.</p>

        <p>The illustrations show both quadratic and cubic curves going through three fixed points, but with different
        <code>t</code> values specified (0.2, 0.3, 0.4, and 0.5). For the cubic example, <code>d1</code> has not between
        explicitly specified. (no skeleton is shown for the cubic curves, as the additional lines crowd the illustration
        too much).</p>
      </section>

      <section id="getLUT">
        <a href="#getLUT"><h1>.getLUT(steps)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              var LUT = curve.getLUT(16);
              LUT.forEach(p => this.drawCircle(p,2));
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              var LUT = curve.getLUT(16);
              LUT.forEach(p => this.drawCircle(p,2));
            }
          </script></figure>
        </figures>

        <p>Generates a <b>L</b>ook<b>U</b>p <b>T</b>able of coordinates on the curve, spaced at parametrically equidistance
          intervals. If <code>steps</code> is given, the LUT will contain <code>steps+1</code> coordinates
          representing the coordinates from <code>t=0</code> to <code>t=1</code> at interval <code>1/steps</code>.</p>

        <p>If <code>steps</code> is omitted, a default value of <code>steps=100</code> is used.</p>
      </section>

      <section id="length">
        <a href="#length"><h1>.length()</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var arclength = curve.length();
              var offset = curve.offset(-10), last=offset.length-1;
              offset.forEach((c,idx) => {
                this.drawCurve(c);
                if(idx===last) {
                  var p1 = curve.offset(0.95, -15);
                  var p2 = c.get(1);
                  var p3 = curve.offset(0.95, -5);
                  this.drawLine(p1,p2);
                  this.drawLine(p2,p3);
                  var label = ((100*arclength)|0)/100 + "px";
                  this.drawText(label, {x:p2.x+7,y:p2.y-3});
                }
              });
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100, 25, 10, 90, 110, 100, 132, 192 );
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var arclength = curve.length();
              var offset = curve.offset(-10), last=offset.length-1;
              offset.forEach((c,idx) => {
                this.drawCurve(c);
                if(idx===last) {
                  var p1 = curve.offset(0.95, -15);
                  var p2 = c.get(1);
                  var p3 = curve.offset(0.95, -5);
                  this.drawLine(p1,p2);
                  this.drawLine(p2,p3);
                  var label = ((100*arclength)|0)/100 + "px";
                  this.drawText(label, {x:p2.x+7,y:p2.y-3});
                }
              });
            }
          </script></figure>
        </figures>

        <p>Calculates the length of this Bezier curve. Length is calculated using numerical approximation,
          specifically the Legendre-Gauss quadrature algorithm.</p>
      </section>

      <section id="get">
        <a href="#get"><h1>.get(t) and .compute(t)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              this.drawPoint(curve.get(0.5));
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              this.drawPoint(curve.get(0.5));
            }
          </script></figure>
        </figures>

        <p>Calculates a point on the curve, for a given <code>t</code> value between 0 and 1 (inclusive).
          <code>.get</code> is an alias for <code>.compute</code>. The illustration graphics show the
          point for <code>t=0.5</code> highlighted on both curves.</p>
      </section>


      <section id="derivative">
        <a href="#derivative"><h1>.derivative(t)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              for(var t=0; t<=1; t+=0.1) {
                var pt = curve.get(t);
                var dv = curve.derivative(t);
                this.drawLine(pt, { x: pt.x + dv.x, y: pt.y + dv.y} );
              }
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              for(var t=0; t<=1; t+=0.1) {
                var pt = curve.get(t);
                var dv = curve.derivative(t);
                this.drawLine(pt, { x: pt.x + dv.x, y: pt.y + dv.y} );
              }
            }
          </script></figure>
        </figures>

        <p>Calculates the curve tangent at the specified <code>t</code> value. Note that this yields
          a not-normalized vector <code>{x: dx, y: dy}</code>.</p>
      </section>

      <section id="normal">
        <a href="#normal"><h1>.normal(t)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var pt, nv, d=20;
              for(var t=0; t<=1; t+=0.1) {
                var pt = curve.get(t);
                var nv = curve.normal(t);
                this.drawLine(pt, { x: pt.x + d*nv.x, y: pt.y + d*nv.y} );
              }
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var pt, nv, d=20;
              for(var t=0; t<=1; t+=0.1) {
                var pt = curve.get(t);
                var nv = curve.normal(t);
                this.drawLine(pt, { x: pt.x + d*nv.x, y: pt.y + d*nv.y} );
              }
            }
          </script></figure>
        </figures>

        <p>Calculates the curve normal at the specified <code>t</code> value. Note that this yields
          a normalised vector <code>{x: nx, y: ny}</code>.</p>

        <p>In 2d, the normal is simply the normalised tangent vector, rotated by a quarter turn. In
          3d, the normal is the normalised tangent vector rotated by a quarter turn through the
          tangential plane.</p>
      </section>

      <section id="split">
        <a href="#split"><h1>.split(t) and .split(t1,t2)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.setColor("lightgrey");
              this.drawCurve(curve);
              var c = curve.split(0.25, 0.75);
              this.setColor("red");
              this.drawCurve(c);
              this.drawCircle(curve.get(0.25),3);
              this.drawCircle(curve.get(0.75),3);
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.setColor("lightgrey");
              this.drawCurve(curve);
              var c = curve.split(0.25, 0.75);
              this.setColor("red");
              this.drawCurve(c);
              this.drawCircle(curve.get(0.25),3);
              this.drawCircle(curve.get(0.75),3);
            }
          </script></figure>
        </figures>

        <p>When only a single <code>t</code> value is given, this function will split a curve at <code>t=...</code>
          into two new curves that together are equivalent to the original curve.</p>

        <p>When two <code>t</code> values are supplied, the curve is split on <code>t1</code>, after which the
          resulting second subcurve is split on (a scaled) <code>t2</code>, yielding a new curve that is equivalent
          to the original curve over the interval <code>[t1,t2]</code>.</p>
      </section>


      <section id="extrema">
        <a href="#extrema"><h1>.extrema()</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.extrema().values.forEach(t => this.drawCircle(curve.get(t),3));
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.extrema().values.forEach(t => this.drawCircle(curve.get(t),3));
            }
          </script></figure>
        </figures>

        <p>Calculates all the extrema on a curve. Extrema are calculated for each dimension,
          rather than for the full curve, so that the result is not the number of convex/concave transitions,
          but the number of those transitions for each separate dimension.</p>

        <p>This function yields an object <code>{x: [num, num, ...], y: [...], z: [...], values: [...]}</code>
          where each dimension lists the array of <code>t</code> values at which an extremum occurs,
          <code>z</code> exists only if the curve was a 3d curve, and the <code>values</code> property is the
          aggregate of the <code>t</code> values across all dimensions.</p>

        <p>These points can be used to determine the reach of a curve.</p>
      </section>

      <section id="inflections">
        <a href="#inflections"><h1>.inflections()</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.inflections().forEach(t => this.drawCircle(curve.get(t),3));
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.inflections().forEach(t => this.drawCircle(curve.get(t),3));
            }
          </script></figure>
        </figures>

        <p>Calculates all the inflection points on on a curve. That is, all points where the curvature
          of the curve changes sign.</p>

        <p>This function yields an array of <code>t</code> values at which inflections occur.</p>

        <p>Note that quadratic curves by definition cannot have inflections.</p>
      </section>

      <section id="curvature">
        <a href="#curvature"><h1>.curvature(t)</h1></a>

          <figures>
            <figure class="quadratic"><script type="text/beziercode">
              new Bezier(120,40 , 50,30 , 75,150);
              var draw = function() {
                this.drawSkeleton(curve);
                this.drawCurve(curve);
                for(var s=0; s<256; s+=2) {
                  this.setColor("rgba(255,127,"+s+",0.6)");
                  let t = s/255;
                  let p = curve.get(t);
                  let n = curve.normal(t);
                  let kr = curve.curvature(t);
                  this.drawLine(p, {
                    x: p.x + n.x * kr.k * 5000,
                    y: p.y + n.y * kr.k * 5000,
                  });
                }
              }
            </script></figure>

            <figure class="cubic"><script type="text/beziercode">
              new Bezier(110,15 , 10,40 , 100,130 , 90,195);
              var draw = function() {
                this.drawSkeleton(curve);
                this.drawCurve(curve);
                for(var s=0; s<256; s+=2) {
                  this.setColor("rgba(255,127,"+s+",0.6)");
                  let t = s/255;
                  let p = curve.get(t);
                  let n = curve.normal(t);
                  let kr = curve.curvature(t);
                  this.drawLine(p, {
                    x: p.x + n.x * kr.k * 5000,
                    y: p.y + n.y * kr.k * 5000,
                  });
                }
              }
            </script></figure>
          </figures>

          <p>Calculates the curvature of the curve at point <code>t</code>, using the curvature formula:</p>

          <p>
          <br><pre>         |     x'y" - y'x"    |
  κ(t) = | ------------------ |
         |  (x'² + y'²)^(3/2) |</pre><br>
          </p>

          <p>This function yields an object <code>{ k:number, r:number}</code> in which the value <code>k</code>
            is the curvature at point <code>t</code> and <code>r</code> is the radius of that curvature, equal to
            <code>1/k</code>. Note that an infinite curvature, e.g. when <code>k=0</code>, is represented as
            <code>r=0</code> as well, rather than as some infinity value.
          </p>
        </section>

        <section id="bbox">
        <a href="#bbox"><h1>.bbox()</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("rgb(255,100,100)");
              this.drawbbox(curve.bbox());
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("rgb(255,100,100)");
              this.drawbbox(curve.bbox());
            }
          </script></figure>
        </figures>

        <p>Calculates (if not cached) the bounding box for this curve, based on its hull coordinates and its extrema.</p>
      </section>

      <section id="hull">
        <a href="#hull"><h1>.hull(t)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("rgb(255,100,100)");
              var hull = curve.hull(0.5)
              this.drawHull(hull);
              this.drawCircle(hull.slice(-1)[0], 5);
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 50,185 , 170,175);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("rgb(255,100,100)");
              var hull = curve.hull(0.5)
              this.drawHull(hull);
              this.drawCircle(hull.slice(-1)[0], 5);
            }
          </script></figure>
        </figures>

        <p>Generates all hull points, at all iterations, for an on-curve point at the specified t-value.
        For quadratic curves, this generates a point[6], and for cubic curves, this generates a point[10],
        where the first iteration is [0,1,2] and [0,1,2,3] respectively, the second iteration is [3,4]
        and [4,5,6] respectively, the third iteration is [5] (the on-curve point for quadratic curves) and
        [7,8] respectively, and the fourth iteration (for cubic curves only) is [9].</p>
      </section>


      <section id="project">
        <a href="#project"><h1>.project(point)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function(evt) {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("rgb(255,100,100)");
              if (evt) {
                var mouse = {x: evt.offsetX, y: evt.offsetY};
                var p = curve.project(mouse);
                this.drawLine(p,mouse);
              }
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 50,185 , 170,175);
            var draw = function(evt) {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("rgb(255,100,100)");
              if (evt) {
                var mouse = {x: evt.offsetX, y: evt.offsetY};
                var p = curve.project(mouse);
                this.drawLine(p,mouse);
              }
            }
          </script></figure>
        </figures>

        <p>Finds the on-curve point closest to the specific off-curve point, using a two-pass projection test
        based on the curve's LUT. A distance comparison finds the closest match, after which a fine interval
        around that match is checked to see if a better projection can be found.</p>
      </section>


      <section id="offset">
        <a href="#offset"><h1>.offset(d) and .offset(t, d)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.offset(25).forEach(c => this.drawCurve(c));
              this.drawPoint(curve.offset(0.5,25));
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 145,179);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.offset(25).forEach(c => this.drawCurve(c));
              this.drawPoint(curve.offset(0.5,25));
            }
          </script></figure>
        </figures>

        <p>If called only with a distance argument, this function creates a new curve, offset along the curve
          normals, at distance <code>d</code>. Note that deep magic lies here and the offset curve of a Bezier
          curve cannot ever be another Bezier curve. As such, this function "cheats" and yields an array of
          curves which, taken together, form a single continuous curve equivalent to what a theoretical offset
          curve would be.</p>

        <p>If both a distance and a <code>t</code> value are given, a coordinate is returned instead, representing
          the point on the curve at <code>t=...</code>, offset along its normal by a distance <code>d</code>.</p>
      </section>

      <section id="reduce">
        <a href="#reduce"><h1>.reduce()</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              var reduced = curve.reduce();
              if(reduced.length>0) {
                reduced.forEach((c,i) => {
                  this.setColor("black");
                  if(i>0) this.drawCircle(c.points[0],3);
                  this.setRandomColor();
                  this.drawCurve(c);
                });
              } else { this.drawCurve(curve); }
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              var reduced = curve.reduce();
              if(reduced.length>0) {
                reduced.forEach((c,i) => {
                  this.setColor("black");
                  if(i>0) this.drawCircle(c.points[0],3);
                  this.setRandomColor();
                  this.drawCurve(c);
                });
              } else { this.drawCurve(curve); }
            }
          </script></figure>
        </figures>

        <p>Reduces a curve to a collection of "simple" subcurves, where a simpleness is defined as having
          all control points on the same side of the baseline (cubics having the additional constraint that the
          control-to-end-point lines may not cross), and an angle between the end point normals no greater
          than 60 degrees.</p>

        <p>The main reason this function exists is to make it possible to scale curves. As mentioned in the
          offset function, curves cannot be offset without cheating, and the cheating is implemented in this
          function. The array of simple curves that this function yields can safely be scaled.</p>
      </section>

      <section id="arcs">
        <a href="#arcs"><h1>.arcs() and .arcs(threshold)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              var arcs = curve.arcs();
              this.setColor("black");
              arcs.forEach(arc => {
                this.setRandomFill(0.1);
                this.drawArc(arc);
              });
            }
          </script></figure>
          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              var arcs = curve.arcs();
              this.setColor("black");
              arcs.forEach(arc => {
                this.setRandomFill(0.1);
                this.drawArc(arc);
              });
            }
          </script></figure>
        </figures>

        <p>Approximates a Bezier curve as a sequence of circular arcs. An optional threshold
          argument controls how well an arc needs to fit to still be considered a reasonable
          approximation. The higher the <code>threshold</code>, the less accurate an arc fit is allowed.
          If no explicit threshold is set, a value of <code>0.5</code> is used.</p>

        <p>This operation is only supported in 2d (for now).</p>

        <p>Arcs come with an <code>.interval</code> property, with two values: <code>interval.start</code>
        and <code>interval.end</code>, which represent the on-curve <code>t</code> values of the interval
        that an arc covers on the original curve.</p>

      </section>


      <section id="scale">
        <a href="#scale"><h1>.scale(d)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.setColor("black");
              var reduced = curve.reduce(),
                  len = reduced.length;
              if(len>0) {
                reduced.forEach((c,i) => {
                  if(i>0) this.drawCircle(c.points[0],3);
                  this.drawCurve(c);
                });
                for(var i=-30; i<=30; i+=10) {
                  this.drawCurve(reduced[(len/2)|0].scale(i));
                }
              } else { this.drawCurve(curve); }
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.setColor("black");
              var reduced = curve.reduce(),
                  len = reduced.length;
              if(len>0) {
                reduced.forEach((c,i) => {
                  if(i>0) this.drawCircle(c.points[0],3);
                  this.drawCurve(c);
                });
                for(var i=-30; i<=30; i+=10) {
                  this.drawCurve(reduced[(len/2)|0].scale(i));
                }
              } else { this.drawCurve(curve); }
            }
          </script></figure>
        </figures>

        <p>Scales a curve with respect to the intersection between the end point normals. Note that this will only
          work if that point exists, which is only guaranteed for simple segments.</p>
      </section>

      <section id="outline">
        <a href="#outline"><h1>.outline(d), .outline(d1,d2), and .outline(d1,d2,d3,d4)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            // new Bezier(150,40 , 80,30 , 105,150);
            new Bezier(150,40 , 80,40 , 105,40);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var doc = c => this.drawCurve(c);
              var outline = curve.outline(25);
              console.log(outline);
              outline.curves.forEach(doc);
              this.setColor("rgba(0,0,255,0.3)");
              outline.offset(10).curves.forEach(doc);
              outline.offset(-10).curves.forEach(doc);
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            // new Bezier(102, 33, 16, 99, 101, 129, 132, 173 );
            new Bezier(50, 100, 120, 100, 80, 100, 150, 100 );
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var doc = c => this.drawCurve(c);
              var outline = curve.outline(25);
              outline.curves.forEach(doc);
              this.setColor("rgba(0,0,255,0.3)");
              outline.offset(10).curves.forEach(doc);
              outline.offset(-10).curves.forEach(doc);
            }
          </script></figure>
        </figures>

        <p>This generates a curve's outline at distance <code>d</code> along the curve normal and anti-normal.
          The result is an array of curves that taken together form the outline path for this curve. The caps
          are cubic beziers with the control points oriented to form a straight line.</p>

        <p>This function yields a <code>PolyBezier</code> object, which has a property <code>.curves</code> that
          houses all the outline segments in sequence, and has a partial Bezier API:</p>

        <ul>
          <li><code>length()</code> - aggregate sum of all segment lenghts.</li>
          <li><code>bbox()</code> - aggregate bounding box fitting all segments.</li>
          <li><code>offset(d)</code> - aggregate offset function yielding a new <code>PolyBezier</code>.</li>
        </ul>

        <p>When only one distance value is given, the outline is generated at distance <code>d</code> on both
          the normal and anti-normal. If two distance values are given, the outline is generated at distance
          <code>d1</code> on along the normal, and <code>d2</code> along the anti-normal.</p>

        <p>Both graphics show the plain outline in red, with the result of calling the PolyBezier's
          <code>outline.offset()</code> with values 10 and -10 in light blue. Note that the PolyBezier
          offset yields "gaps" between discontinuities. How to deal with these gaps is up to you, and
          options involve arc connections with the original outline's connecting vertex as center,
          Bezier connections with controls along the line segments, linear extensions of the segments
          along the tangents, etc.</p>

        <h2>graduated outlines, using .outline(d1,d2,d3,d4)</h2>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            // new Bezier(150,40 , 80,30 , 105,150);
            new Bezier(150,40 , 80,40 , 105,40);            
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var outline = curve.outline(5,5,25,25);
              outline.curves.forEach(c => this.drawCurve(c));
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            // new Bezier(102, 33, 16, 99, 101, 129, 132, 173 );
            new Bezier(50, 100, 120, 100, 80, 100, 150, 100 );
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              var outline = curve.outline(5,5,25,25);
              outline.curves.forEach(c => this.drawCurve(c));
            }
          </script></figure>
        </figures>

        <p>Graduated offsetting is achieved by using four distances measures, where <code>d1</code>
          is the initial offset along the normal, <code>d2</code> the initial distance along the
          anti-normal, <code>d3</code> the final offset along the normal, and <code>d4</code> the
          final offset along the anti-normal.</p>

        </p>The offsets are graduated (near-)linearly with distance along the curve, and it should
          be noted that quadratic curves can only be offset as graduated curve by first raising
          it to a cubic curve and then running through the offsetting algorithm. While the code
          does this automatically, be aware that quadratic curves come with limitations on their
          expressiveness.</p>

      </section>

      <section id="outlineshapes">
        <a href="#outlineshapes"><h1>.outlineshapes(d), .outlineshapes(d1, d2), and .outlineshapes(d1, d2, curveIntersectionThreshold)</h1></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(150,40 , 80,30 , 105,150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.outlineshapes(25).forEach(s => {
                this.setRandomFill(0.2);
                this.drawShape(s);
              });
            }
          </script></figure>

          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,90 , 110,100 , 150,195);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              curve.outlineshapes(25).forEach(s => {
                this.setRandomFill(0.2);
                this.drawShape(s);
              });
            }
          </script></figure>
        </figures>

        <p>This generates a curve's outline as a series of shapes, rather than as a path sequence. Each shape is
          an object <code>{startcap: (bezier), forward: (bezier), endcap: (bezier), back: (bezier)}</code>.
          Additionally, each cap has a <code>.virtual</code> attribute to indicate whether it a true cap for
          the original curve's outline, or an intermediary cap somewhere inside the collection of outline shapes.</p>

        <p>When only one distance value is given, the shape's curve's outlines are generated at distance <code>d</code> on both
          the normal and anti-normal. If two distance values are given, the shape's curve's outlines are generated at distance
          <code>d1</code> on along the normal, and <code>d2</code> along the anti-normal.</p>

        <p>Finally, shapes have an <code>.intersections(othershape)</code> function for finding intersections
          between shapes rather than between individual curves. If <code>curveIntersectionThreshold</code> is provided, it
          will be used for precision of <a href="#curvetocurveintersection">curve to curve intersections</a>.</p>

      </section>

      <section id="intersections">
        <a href="#intersections"><h1>.intersects(), .intersects(line), .intersects(curve), and .intersects(curve, curveIntersectionThreshold)</h1></a>

        <h2>.intersects()</h2>

        <figures>
          <figure class="cubic"><script type="text/beziercode">
            new Bezier(100,25 , 10,180 , 170,165 , 65,70);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              curve.intersects().forEach(pair => {
                var t = pair.split("/").map(v => parseFloat(v));
                this.drawPoint(curve.get(t[0]));
              });
            }
          </script></figure>
        </figures>

        <p>Without arguments, this function checks for self-intersection. This means it has no meaning for
          quadratic curves, which can't self intersect without being a degenerate curve (i.e. having
          coordinates that all lie on the same line, thus not actually being a "curve" so much as a "bizar
          way to draw a line"). Intersections are yielded as an array of <code>float/float</code> strings,
          where the two floats are separated by the character <code>/</code> and both floats corresponding
          to <code>t</code> values on the curve at which the intersection is found.</p>
      </section>

      <section id="intersect-line">
        <a href="#intersect-line"><h2>.intersects(line)</h2></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(58, 173, 26, 28, 163, 104);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              var line = { p1: {x:0, y:175}, p2: {x:200,y:25} };
              this.setColor("red");
              this.drawLine(line.p1, line.p2);
              this.setColor("black");
              curve.intersects(line).forEach(t => this.drawPoint(curve.get(t)));
            }
          </script></figure>
          <figure class="cubic"><script type="text/beziercode">
            new Bezier(53, 163, 27, 19, 182, 176, 155, 36);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              var line = { p1: {x:0, y:175}, p2: {x:200,y:25} };
              this.setColor("red");
              this.drawLine(line.p1, line.p2);
              this.setColor("black");
              curve.intersects(line).forEach(t => this.drawPoint(curve.get(t)));
            }
          </script></figure>
        </figures>

        <p>Finds the intersections between this curve an some line <code>{p1: {x:... ,y:...}, p2: ... }</code>.
          The intersections are an array of <code>t</code> values on this curve.</p>
        <p>Curves are first aligned (translation/rotation) such that the curve's first coordinate is (0,0),
          and the curve is rotated so that the intersecting line coincides with the x-axis. Doing so turns
          "intersection finding" into plain "root finding".</p>
        <p>As a root finding solution, the roots are computed symbolically for both quadratic and cubic curves,
          using the standard square root function which you might remember from high school, and the absolutely
          not standard Cardano's algorithm for solving the cubic root function.</p>
      </section>

      <a name="curvetocurveintersection"></a>

      <section id="intersect-curve">
        <a href="#intersect-curve"><h2>.intersects(curve) and .intersects(curve, curveIntersectionThreshold)</h2></a>

        <figures>
          <figure class="quadratic"><script type="text/beziercode">
            new Bezier(48, 84, 100, 187, 166, 37);
            var curve2 = new Bezier(68, 150, 74, 6, 143, 150);
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              this.drawCurve(curve2);
              this.setColor("black");
              curve.intersects(curve2).forEach(pair => {
                var t = pair.split("/").map(v => parseFloat(v));
                this.drawPoint(curve.get(t[0]));
              });
            }
          </script></figure>
          <figure class="cubic"><script type="text/beziercode">
            new Bezier(48, 84, 104, 176, 190, 37, 121, 75);
            var curve2 = new Bezier(68, 145, 74, 6, 143, 197, 138, 55 );
            var draw = function() {
              this.drawSkeleton(curve);
              this.drawCurve(curve);
              this.setColor("red");
              this.drawCurve(curve2);
              this.setColor("black");
              curve.intersects(curve2).forEach(pair => {
                var t = pair.split("/").map(v => parseFloat(v));
                this.drawPoint(curve.get(t[0]));
              });
            }
          </script></figure>
        </figures>

        <p>Finds the intersections between this curve and another. Intersections are yielded as an array
          of <code>float/float</code> strings, where the two floats are separated by the character <code>/</code>,
          the first floats corresponds to the <code>t</code> value on this curve, and the second float corresponds
          to the <code>t</code> value on the other curve.</p>
        <p>Curve/curve intersection uses an interative process, where curves are subdivided at the midpoint, and
        bounding box overlap checks are performed between the resulting smaller curves. Any overlap is marked as
        a pair to resolve, and the "divide and check overlap" step is repeated. Doing this enough times
        "homes in" on the actual intersections, such that with infinite divisions, we can get an arbitrarily
        close approximation of the <code>t</code> values involved. Thankfully, repeating the process a low number
        of steps is generally good enough to get reliable values (typically 10 steps yields more than acceptable
        precision). When <code>curveIntersectionThreshold</code> is provided, this will be used for bounding box
        comparisons in x and y dimensions so that precision can be specified, otherwise a default value of .5 will be used.</p>

      </section>
    </main>

    <footer>
      <p>Made by <a href="https://twitter.com/TheRealPomax">Pomax</a>. Based on the work done for <a href="http://pomax.github.io/bezierinfo">A Primer on Bézier Curves</a>. Naturally, the code's open source over on <a href="http://github.com/Pomax/bezierjs">github</a>.<br>
      Still to do: intersection resolution for outlines with overlapping extrusions.</p>
    </footer>
  </body>
</html>
